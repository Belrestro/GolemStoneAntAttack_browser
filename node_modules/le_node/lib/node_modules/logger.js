'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _get = require('babel-runtime/helpers/get')['default'];

var _createDecoratedClass = require('babel-runtime/helpers/create-decorated-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slice = require('babel-runtime/helpers/slice')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _Symbol = require('babel-runtime/core-js/symbol')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Number$isInteger = require('babel-runtime/core-js/number/is-integer')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

_Object$defineProperty(exports, '__esModule', {
	value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _defaults = require('defaults');

var defaults = _interopRequireWildcard(_defaults);

var _levels = require('levels');

var levelUtil = _interopRequireWildcard(_levels);

var _codependency = require('codependency');

var _codependency2 = _interopRequireDefault(_codependency);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _text = require('text');

var _text2 = _interopRequireDefault(_text);

var _tls = require('tls');

var _tls2 = _interopRequireDefault(_tls);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _serialize = require('serialize');

var _stream = require('stream');

var _error = require('error');

var $bufferFull = _Symbol('bufferFull property');
var $cannotConnect = _Symbol('cannotConnect property');
var $connection = _Symbol('connection property');
var $console = _Symbol('console property');
var $failedAttempts = _Symbol('failedAttempts property');
var $flatten = _Symbol('flatten property');
var $flattenArrays = _Symbol('flattenArrays property');
var $getConnection = _Symbol('getConnection method');
var $host = _Symbol('host property');
var $json = _Symbol('json property');
var $levels = _Symbol('levels property');
var $Logger = _Symbol('Logger property (winston / bunyan)');
var $minLevel = _Symbol('minLevel property');
var $port = _Symbol('port property');
var $replacer = _Symbol('replacer property');
var $secure = _Symbol('secure property');
var $serialize = _Symbol('serialize method');
var $tempLevel = _Symbol('tempLevel property (winston)');
var $timeout = _Symbol('timeout property');
var $timestamp = _Symbol('timestamp property');
var $token = _Symbol('token property');
var $toLevel = _Symbol('toLevel method');
var $withLevel = _Symbol('withLevel property');
var $withStack = _Symbol('withStack property');

var newline = /\n/g;
var tokenPattern = /[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}/;

var finalizeLogString = function finalizeLogString(log, token) {
	return '' + token + ' ' + log.toString().replace(newline, '\u2028') + '\n';
};

var getConsoleMethod = function getConsoleMethod(lvl) {
	return lvl == 3 ? 'warn' : lvl > 3 ? 'error' : 'log';
};

var getSafeProp = function getSafeProp(log, prop) {
	while (prop in log) prop = '_' + prop;
	return prop;
};

var requirePeer = _codependency2['default'].register(module);

var nonConfigurable = function nonConfigurable(target, name, descriptor) {
	descriptor.configurable = false;
	descriptor.enumerable = true;
	return descriptor;
};

var unwritable = function unwritable(target, name, descriptor) {
	descriptor.writable = false;
	return descriptor;
};

var enumerable = function enumerable(target, name, descriptor) {
	descriptor.enumerable = true;
	return descriptor;
};

var Logger = (function (_Writable) {
	function Logger(opts) {
		var _this = this;

		_classCallCheck(this, Logger);

		_get(Object.getPrototypeOf(Logger.prototype), 'constructor', this).call(this, {
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		if (_lodash2['default'].isUndefined(opts)) throw new _error.BadOptionsError(opts, _text2['default'].noOptions());

		if (!_lodash2['default'].isObject(opts)) throw new _error.BadOptionsError(opts, _text2['default'].optionsNotObj(typeof opts));

		if (_lodash2['default'].isUndefined(opts.token)) throw new _error.BadOptionsError(opts, _text2['default'].noToken());

		if (!_lodash2['default'].isString(opts.token) || !tokenPattern.test(opts.token)) throw new _error.BadOptionsError(opts, _text2['default'].invalidToken(opts.token));

		this[$levels] = levelUtil.normalize(opts);

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			var _loop = function () {
				var lvlName = _step.value;

				if (lvlName in _this) throw new _error.BadOptionsError(opts, _text2['default'].levelConflict(lvlName));

				_Object$defineProperty(_this, lvlName, {
					enumerable: true,
					writable: false,
					value: function value() {
						this.log.apply(this, [lvlName].concat(_slice.call(arguments)));
					}
				});
			};

			for (var _iterator = _getIterator(this.levels), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				_loop();
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator['return']) {
					_iterator['return']();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		this[$token] = opts.token;

		this.port = opts.port || (opts.secure ? defaults.portSecure : defaults.port);

		this.flatten = opts.flatten;
		this.flattenArrays = 'flattenArrays' in opts ? opts.flattenArrays : opts.flatten;

		this.json = opts.json;
		this.host = opts.host;
		this.console = opts.console;
		this.minLevel = opts.minLevel;
		this.replacer = opts.replacer;
		this.timeout = opts.timeout;
		this.timestamp = opts.timestamp;
		this.withLevel = 'withLevel' in opts ? opts.withLevel : true;
		this.withStack = opts.withStack;
		this[$secure] = opts.secure;

		this[$cannotConnect] = false;
		this[$failedAttempts] = 0;
	}

	_inherits(Logger, _Writable);

	_createDecoratedClass(Logger, [{
		key: '_write',
		decorators: [unwritable],
		value: function _write(log, enc, cb) {
			var conn;
			return _regeneratorRuntime.async(function _write$(context$2$0) {
				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						log = finalizeLogString(log, this[$token]);

						context$2$0.prev = 1;
						context$2$0.next = 4;
						return this[$getConnection]();

					case 4:
						conn = context$2$0.sent;

						conn.write(log);

						context$2$0.next = 11;
						break;

					case 8:
						context$2$0.prev = 8;
						context$2$0.t0 = context$2$0['catch'](1);

						this.emit('error', context$2$0.t0);

					case 11:
						context$2$0.prev = 11;

						cb();
						return context$2$0.finish(11);

					case 14:
					case 'end':
						return context$2$0.stop();
				}
			}, null, this, [[1, 8, 11, 14]]);
		}
	}, {
		key: 'end',
		decorators: [unwritable],
		value: function end() {
			var _this2 = this;

			this.on('connection drain', function () {
				return _this2.closeConnection();
			});
			_get(Object.getPrototypeOf(Logger.prototype), 'end', this).apply(this, arguments);
		}
	}, {
		key: 'setDefaultEncoding',
		decorators: [unwritable],
		value: function setDefaultEncoding() {}
	}, {
		key: 'log',
		decorators: [enumerable, unwritable],
		value: function log(lvl, _log) {
			var _this3 = this;

			if (_log === undefined) {
				_log = lvl;
				lvl = null;
			}

			var lvlName = undefined;

			if (lvl || lvl === 0) {
				var _$toLevel = this[$toLevel](lvl);

				var _$toLevel2 = _slicedToArray(_$toLevel, 2);

				lvl = _$toLevel2[0];
				lvlName = _$toLevel2[1];

				if (!lvl && lvl !== 0) {
					this.emit('error', new _error.LogentriesError(_text2['default'].unknownLevel(lvl)));
					return;
				}

				if (lvl < this.minLevel) return;
			}

			if (_lodash2['default'].isArray(_log)) {
				if (_log.length) {
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = _getIterator(_log), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var $log = _step2.value;
							this.log(lvl, $log);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2['return']) {
								_iterator2['return']();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				} else this.emit('error', new _error.LogentriesError(_text2['default'].noLogMessage()));

				return;
			}

			if (_lodash2['default'].isObject(_log)) {

				var safeTime = undefined,
				    safeLevel = undefined;

				if (this.timestamp) {
					safeTime = getSafeProp(_log, 'time');
					_log[safeTime] = new Date();
				}

				if (this.withLevel && lvlName) {
					safeLevel = getSafeProp(_log, 'level');
					_log[safeLevel] = lvlName;
				}

				_log = this[$serialize](_log);

				if (!_log) {
					this.emit('error', new _error.LogentriesError(_text2['default'].serializedEmpty()));
					return;
				}

				if (this.console) console[getConsoleMethod(lvl)](JSON.parse(_log));

				if (safeTime) delete _log[safeTime];
				if (safeLevel) delete _log[safeLevel];
			} else {
				if (_lodash2['default'].isEmpty(_log)) {
					this.emit('error', new _error.LogentriesError(_text2['default'].noLogMessage()));
					return;
				}

				_log = [_log.toString()];

				if (this.withLevel && lvlName) _log.unshift(lvlName);

				if (this.timestamp) _log.unshift(new Date().toISOString());

				_log = _log.join(' ');

				if (this.console) console[getConsoleMethod(lvl)](_log);
			}

			if (this[$bufferFull]) {
				this.emit('error', new _error.LogentriesError(_text2['default'].bufferFull(_log)));
				return;
			}

			this.emit('log', _log);

			var mayWriteFurther = this.write(_log);

			if (!mayWriteFurther) {
				this[$bufferFull] = true;
				this.once('drain', function () {
					return _this3[$bufferFull] = false;
				});
			}
		}
	}, {
		key: 'closeConnection',
		decorators: [enumerable, unwritable],
		value: function closeConnection() {
			if (!this[$connection]) return;

			this[$connection].then(function (conn) {
				return conn.end();
			});
		}
	}, {
		key: $toLevel,
		value: function (val) {
			var num = undefined;

			if (levelUtil.isNumberValid(val)) num = parseInt(parseInt(val));else num = this[$levels].indexOf(val);

			var name = this[$levels][num];

			return name ? [num, name] : [];
		}
	}, {
		key: $getConnection,
		value: function callee$1$0(_resolve, _reject) {
			return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
				var _this4 = this;

				while (1) switch (context$2$0.prev = context$2$0.next) {
					case 0:
						if (!this[$connection]) {
							context$2$0.next = 2;
							break;
						}

						return context$2$0.abrupt('return', this[$connection]);

					case 2:
						if (!this[$failedAttempts]) {
							context$2$0.next = 5;
							break;
						}

						context$2$0.next = 5;
						return new _Promise(function (resolve) {
							setTimeout(resolve, Math.pow(_this4[$failedAttempts], 1.5) * 1000);
						});

					case 5:

						this[$connection] = new _Promise(function (resolve, reject) {
							resolve = _resolve || resolve;
							reject = _reject || reject;

							if (_this4[$cannotConnect]) {
								reject(new _error.LogentriesError(_text2['default'].cannotConnect()));
								return;
							}

							var opts = {
								host: _this4.host,
								port: _this4.port
							};

							var connection = undefined;
							var resolved = false;

							if (_this4.secure) connection = _tls2['default'].connect(opts, function () {
								if (!connection.authorized) {
									_this4[$failedAttempts]++;
									var errMsg = connection.authorizationError;
									_this4.emit(new _error.LogentriesError(_text2['default'].authError(errMsg)));
								}
							});else connection = _net2['default'].createConnection(opts);

							connection.setTimeout(_this4.timeout);

							connection.on('drain', function () {
								return setImmediate(function () {
									return _this4.emit('connection drain');
								});
							});

							connection.on('timeout', function () {
								connection.end();
								delete _this4[$connection];
							});

							connection.on('error', function () {
								connection.destroy();
								delete _this4[$connection];

								if (!resolved) {
									_this4[$failedAttempts]++;

									if (_this4[$failedAttempts] >= defaults.maxFailedAttempts) {
										_this4[$cannotConnect] = true;

										setTimeout(function () {
											_this4[$cannotConnect] = false;
										}, defaults.retryTimeout);
									}

									_this4[$getConnection](resolve, reject);
								}
							});

							connection.on('close', function () {
								delete _this4[$connection];

								_this4.emit('disconnected');
							});

							connection.on('end', function () {
								delete _this4[$connection];
							});

							connection.on('connect', function () {
								_this4[$failedAttempts] = 0;
								resolved = true;
								resolve(connection);

								_this4.emit('connected');
							});
						});

						return context$2$0.abrupt('return', this[$connection]);

					case 7:
					case 'end':
						return context$2$0.stop();
				}
			}, null, this);
		}
	}, {
		key: 'console',
		decorators: [nonConfigurable],
		get: function () {
			return this[$console];
		},
		set: function (val) {
			this[$console] = !!val;
		}
	}, {
		key: 'flatten',
		decorators: [nonConfigurable],
		get: function () {
			return this[$flatten];
		},
		set: function (val) {
			this[$flatten] = !!val;
			this[$serialize] = (0, _serialize.build)(this);
		}
	}, {
		key: 'flattenArrays',
		decorators: [nonConfigurable],
		get: function () {
			return this[$flattenArrays];
		},
		set: function (val) {
			this[$flattenArrays] = !!val;
			this[$serialize] = (0, _serialize.build)(this);
		}
	}, {
		key: 'host',
		decorators: [nonConfigurable],
		get: function () {
			return this[$host];
		},
		set: function (val) {
			if (!_lodash2['default'].isString(val) || !val.length) {
				this[$host] = defaults.host;
				return;
			}

			val = val.replace(/^https?:\/\//, '');

			var url = _url2['default'].parse('http://' + val);

			this[$host] = url.hostname || defaults.host;

			if (url.port) this.port = url.port;
		}
	}, {
		key: 'minLevel',
		decorators: [nonConfigurable],
		get: function () {
			return this[$minLevel];
		},
		set: function (val) {
			var _$toLevel3 = this[$toLevel](val);

			var _$toLevel32 = _slicedToArray(_$toLevel3, 1);

			var num = _$toLevel32[0];

			this[$minLevel] = _lodash2['default'].isNumber(num) ? num : 0;
		}
	}, {
		key: 'port',
		decorators: [nonConfigurable],
		get: function () {
			return this[$port];
		},
		set: function (val) {
			val = parseFloat(val);
			if (_Number$isInteger(val) && _lodash2['default'].inRange(val, 65536)) this[$port] = val;
		}
	}, {
		key: 'replacer',
		decorators: [nonConfigurable],
		get: function () {
			return this[$replacer];
		},
		set: function (val) {
			this[$replacer] = _lodash2['default'].isFunction(val) ? val : undefined;
			this[$serialize] = (0, _serialize.build)(this);
		}
	}, {
		key: 'timeout',
		decorators: [nonConfigurable],
		get: function () {
			return this[$timeout];
		},
		set: function (val) {
			if (_Number$isInteger(val) && val >= 0) this[$timeout] = parseInt(val);

			if (!_lodash2['default'].isNumber(this[$timeout])) this[$timeout] = defaults.timeout;

			this.closeConnection();
		}
	}, {
		key: 'timestamp',
		decorators: [nonConfigurable],
		get: function () {
			return this[$timestamp];
		},
		set: function (val) {
			this[$timestamp] = !!val;
		}
	}, {
		key: 'withLevel',
		decorators: [nonConfigurable],
		get: function () {
			return this[$withLevel];
		},
		set: function (val) {
			this[$withLevel] = !!val;
		}
	}, {
		key: 'withStack',
		decorators: [nonConfigurable],
		get: function () {
			return this[$withStack];
		},
		set: function (val) {
			this[$withStack] = !!val;
			this[$serialize] = (0, _serialize.build)(this);
		}
	}, {
		key: 'levels',
		decorators: [nonConfigurable],
		get: function () {
			return this[$levels] && this[$levels].slice();
		}
	}, {
		key: 'secure',
		decorators: [nonConfigurable],
		get: function () {
			return this[$secure];
		}
	}, {
		key: 'serialize',
		decorators: [nonConfigurable],
		get: function () {
			return this[$serialize];
		}
	}, {
		key: 'level',
		decorators: [unwritable],
		value: function level(name) {
			console.warn(_text2['default'].deprecatedLevelMethod());
			if (~this[$levels].indexOf(name)) this.minLevel = name;
		}
	}, {
		key: 'winston',
		decorators: [unwritable],
		value: function winston() {
			console.warn(_text2['default'].deprecatedWinstonMethod());
		}
	}], [{
		key: 'provisionWinston',
		decorators: [unwritable],
		value: function provisionWinston() {
			var winston = requirePeer('winston');

			if (winston.transports.Logentries) return;

			var Transport = winston.Transport;

			var LogentriesTransport = (function (_Transport) {
				function LogentriesTransport(opts) {
					var _this5 = this;

					_classCallCheck(this, LogentriesTransport);

					_get(Object.getPrototypeOf(LogentriesTransport.prototype), 'constructor', this).call(this, opts);
					this.json = opts.json;

					opts = _lodash2['default'].clone(opts || {});

					opts.minLevel = opts.minLevel || opts.level || this[$tempLevel] || 0;

					opts.levels = opts.levels || winston.levels;

					delete this[$tempLevel];

					this[$Logger] = new Logger(opts);

					this[$Logger].on('error', function (err) {
						return _this5.emit(err);
					});
				}

				_inherits(LogentriesTransport, _Transport);

				_createDecoratedClass(LogentriesTransport, [{
					key: 'log',
					decorators: [enumerable, unwritable],
					value: function log(lvl, msg, meta, cb) {
						if (this.json) {
							var message = {
								message: msg
							};
							if (!_lodash2['default'].isEmpty(meta)) if (_lodash2['default'].isObject(meta)) _lodash2['default'].defaults(message, meta);else message.meta = meta;

							this[$Logger].log(lvl, message);
						} else {
							if (!_lodash2['default'].isEmpty(meta)) if (_lodash2['default'].isString(msg)) msg += ' ' + this[$Logger][$serialize](meta);else if (_lodash2['default'].isObject(msg)) msg[getSafeProp(msg, 'meta')] = meta;

							this[$Logger].log(lvl, msg);
						}

						setImmediate(cb.bind(null, null, true));
					}
				}, {
					key: 'name',
					decorators: [nonConfigurable],
					get: function () {
						return 'logentries';
					}
				}, {
					key: 'level',
					decorators: [nonConfigurable],
					get: function () {
						var _$Logger$$toLevel = this[$Logger][$toLevel](this[$Logger].minLevel);

						var _$Logger$$toLevel2 = _slicedToArray(_$Logger$$toLevel, 2);

						var lvlName = _$Logger$$toLevel2[1];

						return lvlName;
					},
					set: function (val) {
						if (!this[$Logger]) this[$tempLevel] = val;else this[$Logger].minLevel = val;
					}
				}, {
					key: 'levels',
					decorators: [nonConfigurable],
					get: function () {
						return this[$Logger].levels.reduce(function (acc, lvlName, lvlNum) {
							acc[lvlName] = lvlNum;
							return acc;
						}, {});
					}
				}]);

				return LogentriesTransport;
			})(Transport);

			winston.transports.Logentries = LogentriesTransport;
		}
	}, {
		key: 'bunyanStream',
		value: function bunyanStream(opts) {
			var stream = new BunyanStream(opts);

			var _stream$$Logger$$toLevel = stream[$Logger][$toLevel](stream[$Logger].minLevel);

			var _stream$$Logger$$toLevel2 = _slicedToArray(_stream$$Logger$$toLevel, 2);

			var level = _stream$$Logger$$toLevel2[1];

			var type = 'raw';
			var name = 'logentries';

			stream[$Logger].minLevel = 0;

			return { level: level, name: name, stream: stream, type: type };
		}
	}]);

	return Logger;
})(_stream.Writable);

exports['default'] = Logger;

var winston = requirePeer('winston', { optional: true });

if (winston) Logger.provisionWinston();

var BunyanStream = (function (_Writable2) {
	function BunyanStream(opts) {
		var _this6 = this;

		_classCallCheck(this, BunyanStream);

		_get(Object.getPrototypeOf(BunyanStream.prototype), 'constructor', this).call(this, {
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		opts = _lodash2['default'].clone(opts || {});

		opts.timestamp = false;
		opts.levels = opts.levels || defaults.bunyanLevels;

		this[$Logger] = new Logger(opts);

		this[$Logger].on('error', function (err) {
			return _this6.emit(err);
		});
	}

	_inherits(BunyanStream, _Writable2);

	_createDecoratedClass(BunyanStream, [{
		key: '_write',
		decorators: [unwritable],
		value: function _write(log, enc, cb) {
			var lvl = log.level / 10 - 1;

			this[$Logger].log(lvl, log);

			setImmediate(cb);
		}
	}]);

	return BunyanStream;
})(_stream.Writable);

module.exports = exports['default'];
//# sourceMappingURL=logger.js.map
