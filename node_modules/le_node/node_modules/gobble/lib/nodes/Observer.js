'use strict';

var sander = require('sander');
var Node = require('./Node');
var queue = require('../queue');
var GobbleError = require('../utils/GobbleError');
var assign = require('../utils/assign');
var uid = require('../utils/uid');
var makeLog = require('../utils/makeLog');
var config = require('../config');
var extractLocationInfo = require('../utils/extractLocationInfo');
var signals = require('../utils/signals');

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Observer = (function (_Node) {
	function Observer(input, fn, options, id) {
		_classCallCheck(this, Observer);

		_Node.call(this);

		this.input = input;

		this.fn = fn;
		this.options = assign['default']({}, options);

		this.name = id || fn.id || fn.name || "unknown";
		this.id = uid['default'](this.name);
	}

	_inherits(Observer, _Node);

	Observer.prototype.ready = function ready() {
		var _this = this;

		var observation = undefined;

		if (!this._ready) {
			observation = {
				node: this,
				log: makeLog['default'](this),
				env: config['default'].env,
				sander: sander
			};

			this._abort = function () {
				_this._ready = null;
				observation.aborted = true;
			};

			this._ready = this.input.ready().then(function (inputdir) {
				return queue['default'].add(function (fulfil, reject) {
					_this.emit("info", {
						code: "TRANSFORM_START", // TODO
						progressIndicator: true,
						id: _this.id
					});

					var start = Date.now();
					var called = false;

					var callback = function (err) {
						if (called) return;
						called = true;

						if (observation.aborted) {
							reject(signals.ABORTED);
						} else if (err) {
							var stack = err.stack || new Error().stack;

							var _extractLocationInfo = extractLocationInfo['default'](err);

							var file = _extractLocationInfo.file;
							var line = _extractLocationInfo.line;
							var column = _extractLocationInfo.column;

							var gobbleError = new GobbleError['default']({
								inputdir: inputdir,
								stack: stack, file: file, line: line, column: column,
								message: "observation failed",
								id: _this.id,
								code: "TRANSFORMATION_FAILED", // TODO
								original: err
							});

							reject(gobbleError);
						} else {
							_this.emit("info", {
								code: "TRANSFORM_COMPLETE", // TODO
								id: _this.id,
								duration: Date.now() - start
							});

							fulfil(inputdir);
						}
					};

					try {
						observation.changes = _this.input.changes || _this.getChanges(inputdir);

						var promise = _this.fn.call(observation, inputdir, assign['default']({}, _this.options), callback);
						var promiseIsPromise = promise && typeof promise.then === "function";

						if (!promiseIsPromise && _this.fn.length < 3) {
							throw new Error("Observer " + _this.id + " did not return a promise and did not accept callback");
						}

						if (promiseIsPromise) {
							promise.then(function () {
								return callback();
							}, callback);
						}
					} catch (err) {
						callback(err);
					}
				});
			});
		}

		return this._ready;
	};

	Observer.prototype.start = function start() {
		var _this = this;

		if (this._active) {
			return;
		}

		this._active = true;

		// Propagate invalidation events and information
		this._oninvalidate = function (changes) {
			_this._abort();
			_this.emit("invalidate", changes);
		};

		this._oninfo = function (details) {
			return _this.emit("info", details);
		};

		this.input.on("invalidate", this._oninvalidate);
		this.input.on("info", this._oninfo);

		return this.input.start();
	};

	Observer.prototype.stop = function stop() {
		this.input.off("invalidate", this._oninvalidate);
		this.input.off("info", this._oninfo);

		this.input.stop();
		this._active = false;
	};

	Observer.prototype.active = function active() {
		return this._active;
	};

	return Observer;
})(Node['default']);

exports['default'] = Observer;
//# sourceMappingURL=Observer.js.map
