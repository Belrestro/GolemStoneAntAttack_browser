'use strict';

var eventemitter2 = require('eventemitter2');
var crc32 = require('buffer-crc32');
var sander = require('sander');
var path = require('path');
var requireRelative = require('require-relative');
var builtins = require('../builtins');
var index = require('./index');
var config = require('../config');
var GobbleError = require('../utils/GobbleError');
var assign = require('../utils/assign');
var warnOnce = require('../utils/warnOnce');
var compareBuffers = require('../utils/compareBuffers');
var ___serve = require('./serve');
var ___build = require('./build');
var ___watch = require('./watch');
var is = require('../utils/is');
var signals = require('../utils/signals');

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

function enforceCorrectArguments(options) {
	if (options !== undefined && typeof options !== "object") {
		throw new Error("As of gobble 0.9.0, you cannot pass multiple strings to .grab() and .moveTo(). Use path.join() instead");
	}
}

var Node = (function (_EventEmitter2) {
	function Node() {
		_classCallCheck(this, Node);

		this._gobble = true; // makes life easier for e.g. gobble-cli

		// initialise event emitter
		_EventEmitter2.call(this, { wildcard: true });

		this.counter = 1;
		this.inspectTargets = [];
	}

	_inherits(Node, _EventEmitter2);

	// This gets overwritten each time this.ready is overwritten. Until
	// the first time that happens, it's a noop

	Node.prototype._abort = function _abort() {};

	Node.prototype._findCreator = function _findCreator() {
		return this;
	};

	Node.prototype.build = (function (_build) {
		var _buildWrapper = function build(_x) {
			return _build.apply(this, arguments);
		};

		_buildWrapper.toString = function () {
			return _build.toString();
		};

		return _buildWrapper;
	})(function (options) {
		return ___build['default'](this, options);
	});

	Node.prototype.createWatchTask = function createWatchTask() {
		var node = this;
		var watchTask = new eventemitter2.EventEmitter2({ wildcard: true });

		// TODO is this the best place to handle this stuff? or is it better
		// to pass off the info to e.g. gobble-cli?
		var previousDetails = undefined;

		node.on("info", function (details) {
			if (details === previousDetails) return;
			previousDetails = details;
			watchTask.emit("info", details);
		});

		var buildScheduled = undefined;

		node.on("invalidate", function (changes) {
			// A node can depend on the same source twice, which will result in
			// simultaneous rebuilds unless we defer it to the next tick
			if (!buildScheduled) {
				buildScheduled = true;
				watchTask.emit("info", {
					changes: changes,
					code: "BUILD_INVALIDATED"
				});

				process.nextTick(build);
			}
		});

		node.on("error", handleError);

		function build() {
			buildScheduled = false;

			watchTask.emit("build:start");

			node.ready().then(function (outputdir) {
				watchTask.emit("build:end", outputdir);
			})["catch"](handleError);
		}

		function handleError(e) {
			if (e === signals.ABORTED) {
				// these happen shortly after an invalidation,
				// we can ignore them
				return;
			} else {
				watchTask.emit("error", e);
			}
		}

		watchTask.close = function () {
			return node.stop();
		};

		this.start();
		process.nextTick(build);

		return watchTask;
	};

	Node.prototype.exclude = function exclude(patterns, options) {
		if (typeof patterns === "string") {
			patterns = [patterns];
		}
		return new index.Transformer(this, builtins.include, { patterns: patterns, exclude: true, id: options && options.id });
	};

	Node.prototype.getChanges = function getChanges(inputdir) {
		var _this = this;

		var files = sander.lsrSync(inputdir);

		if (!this._files) {
			this._files = files;
			this._checksums = {};

			files.forEach(function (file) {
				_this._checksums[file] = crc32(sander.readFileSync(inputdir, file));
			});

			return files.map(function (file) {
				return { file: file, added: true };
			});
		}

		var added = files.filter(function (file) {
			return ! ~_this._files.indexOf(file);
		}).map(function (file) {
			return { file: file, added: true };
		});
		var removed = this._files.filter(function (file) {
			return ! ~files.indexOf(file);
		}).map(function (file) {
			return { file: file, removed: true };
		});

		var maybeChanged = files.filter(function (file) {
			return ~_this._files.indexOf(file);
		});

		var changed = [];

		maybeChanged.forEach(function (file) {
			var checksum = crc32(sander.readFileSync(inputdir, file));

			if (!compareBuffers['default'](checksum, _this._checksums[file])) {
				changed.push({ file: file, changed: true });
				_this._checksums[file] = checksum;
			}
		});

		return added.concat(removed).concat(changed);
	};

	Node.prototype.grab = (function (_grab) {
		var _grabWrapper = function grab(_x2, _x3) {
			return _grab.apply(this, arguments);
		};

		_grabWrapper.toString = function () {
			return _grab.toString();
		};

		return _grabWrapper;
	})(function (src, options) {
		enforceCorrectArguments(options);
		return new index.Transformer(this, builtins.grab, { src: src, id: options && options.id });
	});

	// Built-in transformers

	Node.prototype.include = (function (_include) {
		var _includeWrapper = function include(_x4, _x5) {
			return _include.apply(this, arguments);
		};

		_includeWrapper.toString = function () {
			return _include.toString();
		};

		return _includeWrapper;
	})(function (patterns, options) {
		if (typeof patterns === "string") {
			patterns = [patterns];
		}
		return new index.Transformer(this, builtins.include, { patterns: patterns, id: options && options.id });
	});

	Node.prototype.inspect = function inspect(target, options) {
		target = path.resolve(config['default'].cwd, target);

		if (options && options.clean) {
			sander.rimraf(target);
		}

		this.inspectTargets.push(target);
		return this; // chainable
	};

	Node.prototype.map = function map(fn, userOptions) {
		warnOnce['default']("node.map() is deprecated. You should use node.transform() instead for both file and directory transforms");
		return this.transform(fn, userOptions);
	};

	Node.prototype.moveTo = function moveTo(dest, options) {
		enforceCorrectArguments(options);
		return new index.Transformer(this, builtins.move, { dest: dest, id: options && options.id });
	};

	Node.prototype.observe = function observe(fn, userOptions) {
		if (typeof fn === "string") {
			fn = tryToLoad(fn);
		}

		return new index.Observer(this, fn, userOptions);
	};

	Node.prototype.observeIf = function observeIf(condition, fn, userOptions) {
		return condition ? this.observe(fn, userOptions) : this;
	};

	Node.prototype.serve = (function (_serve) {
		var _serveWrapper = function serve(_x6) {
			return _serve.apply(this, arguments);
		};

		_serveWrapper.toString = function () {
			return _serve.toString();
		};

		return _serveWrapper;
	})(function (options) {
		return ___serve['default'](this, options);
	});

	Node.prototype.transform = function transform(fn, userOptions) {
		if (typeof fn === "string") {
			// TODO remove this for 0.9.0
			if (fn === "sorcery") {
				warnOnce['default']("Sourcemaps are flattened automatically as of gobble 0.8.0. You should remove the sorcery transformation from your build definition");
				return this;
			}

			fn = tryToLoad(fn);
		}

		// If function takes fewer than 3 arguments, it's a file transformer
		if (fn.length < 3) {
			var options = assign['default']({}, fn.defaults, userOptions, {
				fn: fn,
				cache: {},
				userOptions: assign['default']({}, userOptions)
			});

			if (typeof options.accept === "string" || is.isRegExp(options.accept)) {
				options.accept = [options.accept];
			}

			return new index.Transformer(this, builtins.map, options, fn.id || fn.name);
		}

		// Otherwise it's a directory transformer
		return new index.Transformer(this, fn, userOptions);
	};

	Node.prototype.transformIf = function transformIf(condition, fn, userOptions) {
		return condition ? this.transform(fn, userOptions) : this;
	};

	Node.prototype.watch = (function (_watch) {
		var _watchWrapper = function watch(_x7) {
			return _watch.apply(this, arguments);
		};

		_watchWrapper.toString = function () {
			return _watch.toString();
		};

		return _watchWrapper;
	})(function (options) {
		return ___watch['default'](this, options);
	});

	return Node;
})(eventemitter2.EventEmitter2);

exports['default'] = Node;

function tryToLoad(plugin) {
	try {
		return requireRelative("gobble-" + plugin, process.cwd());
	} catch (err) {
		if (err.message === "Cannot find module 'gobble-" + plugin + "'") {
			throw new GobbleError['default']({
				message: "Could not load gobble-" + plugin + " plugin",
				code: "PLUGIN_NOT_FOUND",
				plugin: plugin
			});
		} else {
			throw err;
		}
	}
}
//# sourceMappingURL=Node.js.map
