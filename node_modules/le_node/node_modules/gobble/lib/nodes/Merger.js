'use strict';

var path = require('path');
var sander = require('sander');
var mapSeries = require('promise-map-series');
var Node = require('./Node');
var session = require('../session');
var uid = require('../utils/uid');
var signals = require('../utils/signals');

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

function mergeDirectories(src, dest) {
	return sander.stat(dest).then(function (stats) {
		if (stats.isDirectory()) {
			// If it's a symlinked dir, we need to convert it to a real dir.
			// Suppose linked-foo/ is a symlink of foo/, and we try to copy
			// the contents of bar/ into linked-foo/ - those files will end
			// up in foo, which is definitely not what we want
			return sander.lstat(dest).then(function (stats) {
				if (stats.isSymbolicLink()) {
					return convertToRealDir(dest);
				}
			}).then(function () {
				return sander.readdir(src).then(function (files) {
					var promises = files.map(function (filename) {
						return mergeDirectories(src + path.sep + filename, dest + path.sep + filename);
					});

					return sander.Promise.all(promises);
				});
			});
		}

		// exists, and is file - overwrite
		return sander.unlink(dest).then(link);
	}, link); // <- failed to stat, means dest doesn't exist

	function link() {
		return sander.symlinkOrCopy(src).to(dest);
	}
}

// TODO make this async
function convertToRealDir(symlinkPath) {
	var originalPath = sander.realpathSync(symlinkPath);

	sander.unlinkSync(symlinkPath);
	sander.mkdirSync(symlinkPath);

	sander.readdirSync(originalPath).forEach(function (filename) {
		sander.symlinkOrCopySync(originalPath, filename).to(symlinkPath, filename);
	});
}

var Merger = (function (_Node) {
	function Merger(inputs, options) {
		_classCallCheck(this, Merger);

		_Node.call(this);

		this.inputs = inputs;
		this.id = uid['default'](options && options.id || "merge");
	}

	_inherits(Merger, _Node);

	Merger.prototype.ready = function ready() {
		var _this = this;

		var aborted = undefined;
		var index = undefined;
		var outputdir = undefined;

		if (!this._ready) {
			this._abort = function () {
				// allows us to short-circuit operations at various points
				aborted = true;
				_this._ready = null;
			};

			index = this.counter++;
			outputdir = path.resolve(session['default'].config.gobbledir, this.id, "" + index);

			this._ready = sander.mkdir(outputdir).then(function () {
				var start = undefined;
				var inputdirs = [];

				return mapSeries(_this.inputs, function (input, i) {
					if (aborted) throw signals.ABORTED;
					return input.ready().then(function (inputdir) {
						return inputdirs[i] = inputdir;
					});
				}).then(function () {
					start = Date.now();

					_this.emit("info", {
						code: "MERGE_START",
						id: _this.id,
						progressIndicator: true
					});

					return mapSeries(inputdirs, function (inputdir) {
						if (aborted) throw signals.ABORTED;
						return mergeDirectories(inputdir, outputdir);
					});
				}).then(function () {
					if (aborted) throw signals.ABORTED;

					_this._cleanup(index);

					_this.emit("info", {
						code: "MERGE_COMPLETE",
						id: _this.id,
						duration: Date.now() - start
					});

					return outputdir;
				});
			});
		}

		return this._ready;
	};

	Merger.prototype.start = function start() {
		var _this = this;

		if (this._active) {
			return;
		}this._active = true;

		this._oninvalidate = function (changes) {
			_this._abort(changes);
			_this.emit("invalidate", changes);
		};

		this._oninfo = function (details) {
			return _this.emit("info", details);
		};

		this.inputs.forEach(function (input) {
			input.on("invalidate", _this._oninvalidate);
			input.on("info", _this._oninfo);

			input.start();
		});
	};

	Merger.prototype.stop = function stop() {
		var _this = this;

		this.inputs.forEach(function (input) {
			input.off("invalidate", _this._oninvalidate);
			input.off("info", _this._oninfo);

			input.stop();
		});

		this._active = false;
	};

	Merger.prototype.active = function active() {
		return this._active;
	};

	Merger.prototype._cleanup = function _cleanup(index) {
		var dir = path.join(session['default'].config.gobbledir, this.id);

		// Remove everything except the last successful output dir.
		// Use readdirSync to eliminate race conditions
		sander.readdirSync(dir).filter(function (file) {
			return file !== ".cache" && +file < index;
		}).forEach(function (file) {
			return sander.rimrafSync(dir, file);
		});
	};

	Merger.prototype._findCreator = function _findCreator(filename) {
		var i = this.inputs.length;
		var node = undefined;

		while (i--) {
			node = this.inputs[i];
			if (node._findCreator(filename)) {
				return node;
			}
		}

		return null;
	};

	return Merger;
})(Node['default']);

exports['default'] = Merger;
//# sourceMappingURL=Merger.js.map
