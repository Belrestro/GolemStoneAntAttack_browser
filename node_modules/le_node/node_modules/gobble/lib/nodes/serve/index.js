'use strict';

var http = require('http');
var path = require('path');
var sander = require('sander');
var tinyLr = require('tiny-lr');
var cleanup = require('../../utils/cleanup');
var session = require('../../session');
var GobbleError = require('../../utils/GobbleError');
var handleRequest = require('./handleRequest');



exports['default'] = serve;
function serve(node) {
	var options = arguments[1] === undefined ? {} : arguments[1];

	var port = options.port || 4567;
	var gobbledir = path.resolve(options.gobbledir || process.env.GOBBLE_TMP_DIR || ".gobble");
	var task = session['default'].create({ gobbledir: gobbledir });

	var buildStarted = Date.now();
	var watchTask = undefined;
	var srcDir = undefined;
	var sourcemapPromises = undefined;
	var server = undefined;
	var serverReady = undefined;
	var lrServer = undefined;
	var lrServerReady = undefined;
	var built = false;
	var firedReadyEvent = false;
	var error = { gobble: "WAITING" };

	task.resume = function (n) {
		node = n;
		watchTask = node.createWatchTask();

		watchTask.on("info", function (details) {
			return task.emit("info", details);
		});

		watchTask.on("error", function (err) {
			error = err;
			task.emit("error", err);
		});

		var buildStart = undefined;
		watchTask.on("build:start", function () {
			return buildStart = Date.now();
		});

		watchTask.on("build:end", function (dir) {
			error = null;
			sourcemapPromises = {};
			srcDir = dir;

			built = true;

			task.emit("built");

			task.emit("info", {
				code: "BUILD_COMPLETE",
				duration: Date.now() - buildStart
			});

			if (!firedReadyEvent && serverReady) {
				task.emit("ready");
				firedReadyEvent = true;
			}

			if (!lrServerReady) {
				return;
			}

			lrServer.changed({ body: { files: "*" } });
		});
	};

	task.close = function () {
		if (node) {
			node.stop();
		}

		return new sander.Promise(function (fulfil) {
			session['default'].destroy();
			server.removeAllListeners();
			server.close(fulfil);
		});
	};

	task.pause = function () {
		error = { gobble: "WAITING" };

		buildStarted = Date.now();

		if (node) {
			node.stop();
		}

		node = null;

		return cleanup['default'](gobbledir);
	};

	server = http.createServer();

	server.on("error", function (err) {
		if (err.code === "EADDRINUSE") {
			// We need to create our own error, so we can pass along port info
			err = new GobbleError['default']({
				port: port,
				code: "PORT_IN_USE",
				message: "port " + port + " is already in use"
			});
		}

		task.emit("error", err);

		process.exit(1);
	});

	server.listen(port, function () {
		serverReady = true;

		if (!firedReadyEvent && built) {
			task.emit("ready");
			firedReadyEvent = true;
		}

		task.emit("info", {
			port: port,
			code: "SERVER_LISTENING"
		});
	});

	server.on("request", function (request, response) {
		handleRequest['default'](srcDir, error, sourcemapPromises, request, response)["catch"](function (err) {
			return task.emit("error", err);
		});
	});

	lrServer = tinyLr();
	lrServer.error = function (err) {
		if (err.code === "EADDRINUSE") {
			task.emit("warning", "a livereload server is already running (perhaps in a separate gobble process?). Livereload will not be available for this session");
		} else {
			task.emit("error", err);
		}
	};

	lrServer.listen(35729, function () {
		lrServerReady = true;
		task.emit("info", {
			code: "LIVERELOAD_RUNNING"
		});
	});

	cleanup['default'](gobbledir).then(function () {
		return task.resume(node);
	}, function (err) {
		return task.emit("error", err);
	});

	return task;
}
//# sourceMappingURL=index.js.map
