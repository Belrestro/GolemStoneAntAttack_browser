{"version":3,"file":"index.js","sources":["../../../../../../src/nodes/build/index.js"],"sourcesContent":["import { resolve } from 'path';\nimport { copydir ,readdir } from 'sander';\nimport cleanup from '../../utils/cleanup';\nimport session from '../../session';\nimport GobbleError from '../../utils/GobbleError';\nimport flattenSourcemaps from '../../utils/flattenSourcemaps';\n\nexport default function ( node, options ) {\n\tif ( !options || !options.dest ) {\n\t\tthrow new GobbleError({\n\t\t\tcode: 'MISSING_DEST_DIR',\n\t\t\ttask: 'build'\n\t\t});\n\t}\n\n\tconst gobbledir = resolve( options.gobbledir || process.env.GOBBLE_TMP_DIR || '.gobble-build' );\n\tconst dest = options.dest;\n\n\t// the return value is an EventEmitter...\n\tconst task = session.create({ gobbledir });\n\tlet promise;\n\tlet previousDetails;\n\n\tfunction build () {\n\t\ttask.emit( 'info', {\n\t\t\tcode: 'BUILD_START'\n\t\t});\n\t\tnode.start();\n\n\t\tnode.on( 'info', details => {\n\t\t\tif ( details === previousDetails ) return;\n\t\t\tpreviousDetails = details;\n\t\t\ttask.emit( 'info', details );\n\t\t});\n\n\t\treturn node.ready()\n\t\t\t.then( inputdir => {\n\t\t\t\treturn copydir( inputdir ).to( dest )\n\t\t\t\t\t.then( () => flattenSourcemaps( inputdir, dest, dest, task ) );\n\t\t\t})\n\t\t\t.then( () => node.stop() ); // TODO should not need to stop...\n\t}\n\n\tpromise = cleanup( gobbledir )\n\t\t.then( () => {\n\t\t\treturn readdir( dest ).then( files => {\n\t\t\t\tif ( files.length && !options.force ) {\n\t\t\t\t\tthrow new GobbleError({\n\t\t\t\t\t\tmessage: `destination folder (${dest}) is not empty`,\n\t\t\t\t\t\tcode: 'DIR_NOT_EMPTY',\n\t\t\t\t\t\tpath: dest\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn cleanup( dest ).then( build );\n\t\t\t}, build );\n\t\t})\n\t\t.then(\n\t\t\t() => {\n\t\t\t\ttask.emit( 'complete' );\n\t\t\t\tsession.destroy();\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tsession.destroy();\n\t\t\t\ttask.emit( 'error', err );\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t);\n\n\t// that does double duty as a promise\n\ttask.then = function () {\n\t\treturn promise.then.apply( promise, arguments );\n\t};\n\n\ttask.catch = function () {\n\t\treturn promise.catch.apply( promise, arguments );\n\t};\n\n\treturn task;\n}\n"],"names":[],"mappings":"AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,qBAOe,UAAW,MAAM,SAAU;AACzC,CAAD,IAAM,CAAC,WAAW,CAAC,QAAQ,MAAO;AAChC,EAAF,MAAQ,IATR,sBASuB,CAAC;AACrB,GAAH,MAAS;AACN,GAAH,MAAS;AACT;AACA;;AAEC,CAAD,IAAO,YAfP,YAe0B,CAAE,QAAQ,aAAa,QAAQ,IAAI,kBAAkB;AAC9E,CAAD,IAAO,OAAO,QAAQ;;;AAGrB,CAAD,IAAO,OAnBP,kBAmBqB,CAAC,OAAO,EAAE,WAAA;AAC9B,CAAD,IAAK,UAAL;AACC,CAAD,IAAK,kBAAL;;AAEC,CAAD,SAAU,QAAS;AACjB,EAAF,KAAO,KAAM,QAAQ;AAClB,GAAH,MAAS;AACT;AACE,EAAF,KAAO;;AAEL,EAAF,KAAO,GAAI,QAAQ,UAAA,SAAW;AAC3B,GAAH,IAAQ,YAAY,iBAAkB;AACnC,GAAH,kBAAqB;AAClB,GAAH,KAAQ,KAAM,QAAQ;AACtB;;AAEE,EAAF,OAAS,KAAK,QACV,KAAM,UAAA,UAAY;AAClB,GAAJ,OArCA,cAqCkB,CAAE,UAAW,GAAI,MAC7B,KAAM,YADZ;AACA,IAAA,OAtCA,4BAsCmC,CAAE,UAAU,MAAM,MAAM;AAA3D;AACA,KACI,KAAM,YADV;AACA,GAAA,OAAgB,KAAK;AAArB;AACA;;AAEC,CAAD,UA3CA,kBA2CkB,CAAE,WACjB,KAAM,YAAM;AACZ,EAAH,OA7CA,cA6CiB,CAAE,MAAO,KAAM,UAAA,OAAS;AACrC,GAAJ,IAAS,MAAM,UAAU,CAAC,QAAQ,OAAQ;AACrC,IAAL,MAAW,IA/CX,sBA+C0B,CAAC;AACrB,KAAN,SAAA,yBAAsC,OAAtC;AACM,KAAN,MAAY;AACN,KAAN,MAAY;AACZ;AACA;;AAEI,GAAJ,OAtDA,kBAsDkB,CAAE,MAAO,KAAM;AACjC,KAAM;AACN,IACG,KACA,YAAM;AACL,EAAJ,KAAS,KAAM;AACX,EA5DJ,kBA4DW,CAAC;AACZ,IACG,UAAA,KAAO;AACN,EA/DJ,kBA+DW,CAAC;AACR,EAAJ,KAAS,KAAM,SAAS;AACpB,EAAJ,MAAU;AACV;;;AAIC,CAAD,KAAM,OAAO,YAAY;AACvB,EAAF,OAAS,QAAQ,KAAK,MAAO,SAAS;AACtC;;AAEC,CAAD,KAAA,WAAc,YAAY;AACxB,EAAF,OAAS,QAAT,SAAuB,MAAO,SAAS;AACvC;;AAEC,CAAD,OAAQ;AACR,CAAC"}