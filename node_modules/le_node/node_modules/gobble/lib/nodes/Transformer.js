'use strict';

var path = require('path');
var sander = require('sander');
var Node = require('./Node');
var session = require('../session');
var queue = require('../queue');
var GobbleError = require('../utils/GobbleError');
var assign = require('../utils/assign');
var uid = require('../utils/uid');
var makeLog = require('../utils/makeLog');
var config = require('../config');
var warnOnce = require('../utils/warnOnce');
var extractLocationInfo = require('../utils/extractLocationInfo');
var signals = require('../utils/signals');

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Transformer = (function (_Node) {
	function Transformer(input, transformer, options, id) {
		var _this = this;

		_classCallCheck(this, Transformer);

		_Node.call(this);

		this.input = input;

		this.transformer = transformer;
		this.options = assign['default']({}, options);

		this.name = id || this.options.id || transformer.id || transformer.name || "unknown";
		this.id = uid['default'](this.name);

		// Double callback style deprecated as of 0.6.x. TODO remove this eventually
		if (transformer.length === 5) {
			warnOnce['default']("The gobble plugin API has changed - the \"%s\" transformer should take a single callback. See https://github.com/gobblejs/gobble/wiki/Troubleshooting for more info", this.name);

			this.transformer = function (inputdir, outputdir, options, callback) {
				return transformer.call(_this, inputdir, outputdir, options, function () {
					return callback();
				}, callback);
			};
		}
	}

	_inherits(Transformer, _Node);

	Transformer.prototype.ready = function ready() {
		var _this = this;

		var outputdir = undefined;
		var transformation = undefined;

		if (!this._ready) {
			transformation = {
				node: this,
				cachedir: path.resolve(session['default'].config.gobbledir, this.id, ".cache"),
				log: makeLog['default'](this),
				env: config['default'].env,
				sander: sander
			};

			this._abort = function () {
				_this._ready = null;
				transformation.aborted = true;
			};

			outputdir = path.resolve(session['default'].config.gobbledir, this.id, "" + this.counter++);

			this._ready = this.input.ready().then(function (inputdir) {
				return sander.mkdir(outputdir).then(function () {
					return queue['default'].add(function (fulfil, reject) {
						_this.emit("info", {
							code: "TRANSFORM_START",
							progressIndicator: true,
							id: _this.id
						});

						var start = Date.now();
						var called = false;

						var callback = function (err) {
							if (called) return;
							called = true;

							if (transformation.aborted) {
								reject(signals.ABORTED);
							} else if (err) {
								var stack = err.stack || new Error().stack;

								var _extractLocationInfo = extractLocationInfo['default'](err);

								var file = _extractLocationInfo.file;
								var line = _extractLocationInfo.line;
								var column = _extractLocationInfo.column;

								var gobbleError = new GobbleError['default']({
									inputdir: inputdir, outputdir: outputdir,
									stack: stack, file: file, line: line, column: column,
									message: "transformation failed",
									id: _this.id,
									code: "TRANSFORMATION_FAILED",
									original: err
								});

								reject(gobbleError);
							} else {
								_this.emit("info", {
									code: "TRANSFORM_COMPLETE",
									id: _this.id,
									duration: Date.now() - start
								});

								_this._cleanup(outputdir);
								fulfil(outputdir);
							}
						};

						try {
							transformation.changes = _this.input.changes || _this.getChanges(inputdir);

							var promise = _this.transformer.call(transformation, inputdir, outputdir, assign['default']({}, _this.options), callback);

							if (promise && typeof promise.then === "function") {
								promise.then(function () {
									return callback();
								}, callback);
							}
						} catch (err) {
							callback(err);
						}
					});
				});
			});
		}

		return this._ready;
	};

	Transformer.prototype.start = function start() {
		var _this = this;

		if (this._active) {
			return;
		}

		this._active = true;

		// Propagate invalidation events and information
		this._oninvalidate = function (changes) {
			_this._abort();
			_this.emit("invalidate", changes);
		};

		this._oninfo = function (details) {
			return _this.emit("info", details);
		};

		this.input.on("invalidate", this._oninvalidate);
		this.input.on("info", this._oninfo);

		return sander.mkdir(session['default'].config.gobbledir, this.id).then(function () {
			return _this.input.start();
		});
	};

	Transformer.prototype.stop = function stop() {
		this.input.off("invalidate", this._oninvalidate);
		this.input.off("info", this._oninfo);

		this.input.stop();
		this._active = false;
	};

	Transformer.prototype.active = function active() {
		return this._active;
	};

	Transformer.prototype._cleanup = function _cleanup(latest) {
		var dir = path.join(session['default'].config.gobbledir, this.id);

		// Remove everything except the last successful outputdir and the cachedir
		// Use readdirSync to eliminate race conditions
		sander.readdirSync(dir).filter(function (file) {
			return file !== ".cache" && path.resolve(dir, file) !== latest;
		}).forEach(function (file) {
			return sander.rimrafSync(dir, file);
		});
	};

	return Transformer;
})(Node['default']);

exports['default'] = Transformer;
//# sourceMappingURL=Transformer.js.map
