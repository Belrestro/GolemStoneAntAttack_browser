'use strict';

var path = require('path');
var chalk = require('chalk');
var Queue = require('../queue/Queue');
var sander = require('sander');
var assign = require('../utils/assign');
var config = require('../config');
var extractLocationInfo = require('../utils/extractLocationInfo');
var is = require('../utils/is');
var signals = require('../utils/signals');
var sourcemap = require('../utils/sourcemap');



exports['default'] = map;

function map(inputdir, outputdir, options) {
	var _this = this;

	var changed = {};
	this.changes.forEach(function (change) {
		if (!change.removed) {
			changed[change.file] = true;
		}
	});

	return new sander.Promise(function (fulfil, reject) {
		var queue = new Queue['default']();

		queue.once("error", reject);

		sander.lsr(inputdir).then(function (files) {
			var promises = files.map(function (filename) {
				if (_this.aborted) return;

				var ext = path.extname(filename);

				// change extension if necessary, e.g. foo.coffee -> foo.js
				var destname = options.ext && ~options.accept.indexOf(ext) ? filename.substr(0, filename.length - ext.length) + options.ext : filename;

				var src = path.join(inputdir, filename);
				var dest = path.join(outputdir, destname);

				// If this mapper only accepts certain extensions, and this isn't
				// one of them, just copy the file
				if (shouldSkip(options, ext, filename)) {
					return sander.symlinkOrCopy(src).to(dest);
				}

				// If this file *does* fall within this transformer's remit, but
				// hasn't changed, we just copy the cached file
				if (!changed[filename] && options.cache.hasOwnProperty(filename)) {
					return sander.symlinkOrCopy(options.cache[filename]).to(dest);
				}

				// Otherwise, we queue up a transformation
				return queue.add(function (fulfil, reject) {
					if (_this.aborted) {
						return reject(signals.ABORTED);
					}

					// Create context object - this will be passed to transformers
					var context = {
						log: _this.log,
						env: config['default'].env,
						src: src, dest: dest, filename: filename
					};

					var transformOptions = assign['default']({}, options.fn.defaults, options.userOptions);

					delete transformOptions.accept;
					delete transformOptions.ext;

					return sander.readFile(src).then(function (buffer) {
						return buffer.toString(transformOptions.sourceEncoding);
					}).then(function (data) {
						if (_this.aborted) return reject(signals.ABORTED);

						var result = undefined;

						try {
							result = options.fn.call(context, data, transformOptions);
						} catch (e) {
							var err = createTransformError(e, src, filename, _this.node);
							return reject(err);
						}

						var codepath = path.resolve(_this.cachedir, filename);

						var _processResult = processResult(result, data, src, dest, codepath);

						var code = _processResult.code;
						var map = _processResult.map;

						writeToCacheDir(code, map, codepath, dest).then(function () {
							return sander.symlinkOrCopy(codepath).to(dest);
						}).then(function () {
							return options.cache[filename] = codepath;
						}).then(fulfil);
					})["catch"](reject);
				})["catch"](function (err) {
					queue.abort();
					throw err;
				});
			});

			return sander.Promise.all(promises);
		}).then(function () {
			queue.off("error", reject);
			fulfil();
		}, reject);
	});
}

function processResult(result, original, src, dest, codepath) {
	if (typeof result === "object" && "code" in result) {
		// if a sourcemap was returned, use it
		if (result.map) {
			return {
				code: result.code.replace(sourcemap.SOURCEMAP_COMMENT, "") + sourcemap.getSourcemapComment(encodeURI(codepath + ".map"), path.extname(codepath)),
				map: processSourcemap(result.map, src, dest, original)
			};
		}

		// otherwise we might have an inline sourcemap
		else {
			return processInlineSourceMap(result.code, src, dest, original, codepath);
		}
	}

	if (typeof result === "string") {
		return processInlineSourceMap(result, src, dest, original, codepath);
	}

	return { code: result, map: null };
}

function isDataURI(str) {
	return /^data:/.test(str); // TODO beef this up
}

function processInlineSourceMap(code, src, dest, original, codepath) {
	// if there's an inline sourcemap, process it
	var match = sourcemap.SOURCEMAP_COMMENT.exec(code);
	var map = null;

	if (match && isDataURI(match[1])) {
		match = /base64,(.+)$/.exec(match[1]);

		if (!match) {
			throw new Error("sourceMappingURL is not base64-encoded");
		}

		var json = atob(match[1]);

		map = processSourcemap(json, src, dest, original);
		code = code.replace(sourcemap.SOURCEMAP_COMMENT, "") + sourcemap.getSourcemapComment(encodeURI(codepath + ".map"), path.extname(codepath));
	}

	return { code: code, map: map };
}

function writeToCacheDir(code, map, codepath) {
	if (map) {
		return sander.Promise.all([sander.writeFile(codepath, code), sander.writeFile(codepath + ".map", JSON.stringify(map))]);
	} else {
		return sander.writeFile(codepath, code);
	}
}

function createTransformError(original, src, filename, node) {
	var err = typeof original === "string" ? new Error(original) : original;

	var message = "An error occurred while processing " + chalk.magenta(src);
	var creator = undefined;

	if (creator = node.input._findCreator(filename)) {
		message += " (this file was created by the " + creator.id + " transformation)";
	}

	var _extractLocationInfo = extractLocationInfo['default'](err);

	var line = _extractLocationInfo.line;
	var column = _extractLocationInfo.column;

	err.file = src;
	err.line = line;
	err.column = column;

	return err;
}

function processSourcemap(map, src, dest, data) {
	if (typeof map === "string") {
		map = JSON.parse(map);
	}

	if (!map) {
		return null;
	}

	map.file = dest;
	map.sources = [src];
	map.sourcesContent = [data];
	return map;
}

function shouldSkip(options, ext, filename) {
	var filter = undefined;

	if (filter = options.accept) {
		var i = undefined;

		for (i = 0; i < filter.length; i++) {
			var flt = filter[i];

			if (typeof flt === "string" && flt === ext) {
				return false;
			} else if (is.isRegExp(flt) && flt.test(filename)) {
				return false;
			}
		}

		return true;
	}

	return false;
}

function atob(base64) {
	return new Buffer(base64, "base64").toString("utf8");
}
//# sourceMappingURL=map.js.map
