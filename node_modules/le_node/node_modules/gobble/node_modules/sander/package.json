{
  "name": "sander",
  "description": "Promise-based power tool for common filesystem tasks",
  "author": {
    "name": "Rich Harris"
  },
  "version": "0.3.4",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rich-harris/sander.git"
  },
  "dependencies": {
    "es6-promise": "^2.0.0",
    "mkdirp": "^0.5.0",
    "rimraf": "^2.2.8",
    "graceful-fs": "^3.0.4"
  },
  "main": "dist/sander.js",
  "jsnext:main": "src/sander.js",
  "devDependencies": {
    "buffer-crc32": "^0.2.3",
    "gobble": "^0.9.2",
    "gobble-babel": "^5.1.0",
    "gobble-cli": "^0.4.1",
    "gobble-esperanto-bundle": "^0.1.7",
    "mocha": "^2.2.4"
  },
  "scripts": {
    "test": "mocha",
    "pretest": "npm run build",
    "build": "gobble build -f dist",
    "prepublish": "npm run build && npm test"
  },
  "files": [
    "src",
    "dist",
    "README.md"
  ],
  "readme": "# sander\n\nA Promise-based power tool for common filesystem tasks in node.js.\n\n## Installation\n\n```bash\nnpm install sander\n```\n\n## Another wrapper around `fs`? Really?\n\nYup. Working with the low-level `fs` API is the fastest road to callback hell, and while a lot of the existing `fs` wrappers add a whole load of missing features, they don't really mitigate the fundamental suckiness of working with the filesystem in a painful, imperative way, which forces you to handle errors at every step of the journey towards the centre of the node.js [pyramid of doom](http://stackoverflow.com/search?q=pyramid+of+doom).\n\n**Enough! Manual filing is tedious - you need a power tool.** Instead of writing this...\n\n```js\nvar path = require( 'path' ),\n    fs = require( 'fs' ),\n    mkdirp = require( 'mkdirp' );\n\nvar dest = path.resolve( basedir, filename );\n\nmkdirp( path.dirname( dest ), function ( err ) {\n  if ( err ) throw err;\n\n  fs.writeFile( dest, data, function ( err ) {\n    if ( err ) throw err;\n    doTheNextThing();\n  });\n});\n```\n\n...write this:\n\n```js\nvar sander = require( 'sander' );\nsander.writeFile( basedir, filename, data ).then( doTheNextThing );\n```\n\nIt uses [graceful-fs](https://github.com/isaacs/node-graceful-fs) rather than the built-in `fs` module, to eliminate [EMFILE](http://blog.izs.me/post/56827866110/wtf-is-emfile-and-why-does-it-happen-to-me) from the list of things you have to worry about.\n\n\n## Conventions\n\n### Promises\n\nAll async methods (those whose `fs` equivalents would take a callback, e.g. `sander.readFile`) return a Promise. If you're not familiar with Promises, [read up on them on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) - they're coming in ES6 and are already supported in many browsers, and I guarantee they'll make your life easier.\n\n(Node doesn't natively support promises yet - we're using [es6-promise](https://github.com/jakearchibald/es6-promise) for maximum compatibility. For convenience, the `Promise` constructor is exposed as `sander.Promise`.)\n\n### Intermediate folder creation\n\nWhen writing files and folders, intermediate folders are automatically created as necessary. (I've never encountered a situation where I wanted an `ENOENT` error instead of having this be done for me.)\n\n### Automatic path resolution\n\nWherever appropriate, method arguments are joined together with `path.resolve()` - so the following are equivalent:\n\n```js\nsander.readFile( 'foo', 'bar', 'baz' );\nsander.readFile( path.resolve( 'foo', 'bar', 'baz' ) );\nsander.readFile( 'foo/bar/baz' ); // or 'foo\\bar\\baz' on Windows\n```\n\n### Methods that involve two paths\n\nSome operations, such as renaming files, require two paths to be specified. The convention for handling this in sander is as follows:\n\n```js\nsander.rename( basedir, oldname ).to( basedir, newname );\n```\n\n\n\n## Methods\n\n### `fs` methods\n\nIn addition to the extra methods (listed below), all `fs` methods have `sander` equivalents. The synchronous methods (those ending `Sync`) are the same as the `fs` originals except that path resolution and intermediate folder creation are automatically handled (see [conventions](#conventions), above). All async methods return a promise.\n\nFor more information about what these methods do, consult the [node documentation](http://nodejs.org/api/fs.html).\n\nIn the list below, `...paths` indicates you can use one or more strings in sequence, as per the [automatic path resolution](#automatic-path-resolution) convention. An `fd` argument refers to a file descriptor, which you'd generate with `sander.open()` or `sander.openSync()`. Arguments wrapped in `[]` characters are optional.\n\n```js\nsander.appendFile(...paths, data, [options])\nsander.appendFileSync(...paths, data, [options])\nsander.chmod(...paths, {mode: mode})\nsander.chmodSync(...paths, {mode: mode})\nsander.chown(...paths, uid, gid)\nsander.chownSync(...paths, uid, gid)\nsander.close(fd)\nsander.closeSync(fd)\nsander.createReadStream(...paths, [options])\nsander.createWriteStream(...paths, [options])\nsander.exists(...paths)\nsander.existsSync(...paths)\nsander.fchmod(fd, {mode: mode})\nsander.fchmodSync(fd, {mode: mode})\nsander.fchown(fd, uid, gid)\nsander.fchownSync(fd, uid, gid)\nsander.fstat(fd)\nsander.fstatSync(fd)\nsander.fsync(fd)\nsander.fsyncSync(fd)\nsander.ftruncate(fd, len)\nsander.ftruncateSync(fd, len)\nsander.futimes(fd, atime, mtime)\nsander.futimesSync(fd, atime, mtime)\nsander.lchmod(...paths, {mode: mode})\nsander.lchmodSync(...paths, {mode: mode})\nsander.lchown(...paths, uid, gid)\nsander.lchownSync(...paths, uid, gid)\nsander.link(...paths).to(...paths)\nsander.linkSync(...paths).to(...paths)\nsander.lstat(...paths)\nsander.lstatSync(...paths)\nsander.mkdir(...paths, [{mode: mode}])\nsander.mkdirSync(...paths, [{mode: mode}])\nsander.open(...paths, flags, [{mode: mode}])\nsander.openSync(...paths, flags, [{mode: mode}])\nsander.read(fd, buffer, offset, length, position)\nsander.readSync(fd, buffer, offset, length, position)\nsander.readdir(...paths)\nsander.readdirSync(...paths)\nsander.readFile(...paths, [options])\nsander.readFileSync(...paths, [options])\nsander.readlink(...paths)\nsander.readlinkSync(...paths)\nsander.realpath(...paths, [cache])\nsander.realpathSync(...paths, [cache])\nsander.rename(...paths).to(...paths)\nsander.renameSync(...paths).to(...paths)\nsander.rmdir(...paths)\nsander.rmdirSync(...paths)\nsander.stat(...paths)\nsander.statSync(...paths)\nsander.symlink(...paths).to(...paths, [{type: type}])\nsander.symlinkSync(...paths).to(...paths, [{type: type}])\nsander.truncate(...paths, len)\nsander.truncateSync(...paths, len)\nsander.unlink(...paths)\nsander.unlinkSync(...paths)\nsander.utimes(...paths, atime, mtime)\nsander.utimesSync(...paths, atime, mtime)\nsander.unwatchFile(...paths, [listener])\nsander.watch(...paths, [options], [listener])\nsander.watchFile(...paths, [options], listener)\nsander.write(fd, buffer, offset, length, position)\nsander.writeSync(fd, buffer, offset, length, position)\nsander.writeFile(...paths, data, [options])\nsander.writeFileSync(...paths, data, [options])\n```\n\nNote that with the `chmod`/`fchmod`/`lchmod`/`symlink`/`mkdir`/`open` methods (and their synchronous equivalents), the `mode` and `type` arguments must be passed as objects with a `mode` or `type` property. This is so that sander knows which arguments should be treated as parts of a path (because they're strings) and which shouldn't.\n\nThe same is true for methods like `readFile` - whereas in node you can do `fs.readFile('path/to/file.txt', 'utf-8')` if you want to specify utf-8 encoding, with sander the final argument should be a `{encoding: 'utf-8'}` object.\n\n\n### Extra methods\n\n```js\n// Copy a file using streams. `readOptions` is passed to `fs.createReadStream`,\n// while `writeOptions` is passed to `fs.createWriteStream`\nsander.copyFile(...paths, [readOptions]).to(...paths, [writeOptions])\n\n// Copy a file synchronously. `readOptions`, is passed to `fs.readFileSync`,\n// while `writeOptions` is passed to `fs.writeFileSync`\nsander.copyFileSync(...paths, [readOptions]).to(...paths, [writeOptions])\n\n// Copy a directory, recursively. `readOptions` and `writeOptions` are\n// treated as per `sander.copyFile[Sync]`\nsander.copydir(...paths, [readOptions]).to(...paths, [writeOptions])\nsander.copydirSync(...paths, [readOptions]).to(...paths, [writeOptions])\n\n// List contents of a directory, recursively\nsander.lsr(...paths)\nsander.lsrSync(...paths)\n\n// Remove a directory and its contents\nsander.rimraf(...paths)\nsander.rimrafSync(...paths)\n\n// Symlink a file or directory, unless we're on Windows in which\n// case fall back to copying to avoid permissions issues\nsander.symlinkOrCopy(...paths).to(...paths);\nsander.symlinkOrCopySync(...paths).to(...paths);\n```\n\n\n### License\n\nMIT\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rich-harris/sander/issues"
  },
  "homepage": "https://github.com/rich-harris/sander#readme",
  "_id": "sander@0.3.4",
  "_shasum": "86f24ecf043066dac891fad61b59261e98cb6de6",
  "_resolved": "https://registry.npmjs.org/sander/-/sander-0.3.4.tgz",
  "_from": "https://registry.npmjs.org/sander/-/sander-0.3.4.tgz"
}
