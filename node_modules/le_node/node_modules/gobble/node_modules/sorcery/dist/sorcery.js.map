{"version":3,"file":"sorcery.js","sources":["../../01-babel/1/Chain.js","../../01-babel/1/Chain.js","../../01-babel/1/Chain.js","../../01-babel/1/Chain.js","","../../01-babel/1/utils/btoa.js","../../01-babel/1/SourceMap.js","../../01-babel/1/SourceMap.js","../../01-babel/1/utils/encodeMappings.js","../../01-babel/1/Chain.js","../../01-babel/1/Chain.js","","../../01-babel/1/Chain.js","","../../01-babel/1/Node.js","../../01-babel/1/utils/decodeMappings.js","../../01-babel/1/utils/decodeMappings.js","../../01-babel/1/utils/decodeMappings.js","../../01-babel/1/utils/atob.js","../../01-babel/1/utils/getMapFromUrl.js","../../01-babel/1/utils/getSourceMappingUrl.js","../../01-babel/1/utils/getMap.js","../../01-babel/1/Node.js","../../01-babel/1/Node.js","../../01-babel/1/Node.js","","../../01-babel/1/index.js","../../01-babel/1/index.js","../../01-babel/1/index.js",""],"sourcesContent":["var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n"," // js","/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nexport default btoa;\n\nfunction btoa(str) {\n  return new Buffer(str).toString('base64');\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/btoa.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport btoa from './utils/btoa';\n\nvar SourceMap = (function () {\n\tfunction SourceMap(properties) {\n\t\t_classCallCheck(this, SourceMap);\n\n\t\tthis.version = 3;\n\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = properties.mappings;\n\t}\n\n\tSourceMap.prototype.toString = function toString() {\n\t\treturn JSON.stringify(this);\n\t};\n\n\tSourceMap.prototype.toUrl = function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t};\n\n\treturn SourceMap;\n})();\n\nexport default SourceMap;\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/SourceMap.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport btoa from './utils/btoa';\n\nvar SourceMap = (function () {\n\tfunction SourceMap(properties) {\n\t\t_classCallCheck(this, SourceMap);\n\n\t\tthis.version = 3;\n\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = properties.mappings;\n\t}\n\n\tSourceMap.prototype.toString = function toString() {\n\t\treturn JSON.stringify(this);\n\t};\n\n\tSourceMap.prototype.toUrl = function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t};\n\n\treturn SourceMap;\n})();\n\nexport default SourceMap;\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/SourceMap.js.map\n","\n\nexport default encodeMappings;\nimport { encode } from 'vlq';\nfunction encodeMappings(decoded) {\n\tvar offsets = {\n\t\tgeneratedCodeColumn: 0,\n\t\tsourceFileIndex: 0, // second field\n\t\tsourceCodeLine: 0, // third field\n\t\tsourceCodeColumn: 0, // fourth field\n\t\tnameIndex: 0 // fifth field\n\t};\n\n\treturn decoded.map(function (line) {\n\t\toffsets.generatedCodeColumn = 0; // first field - reset each time\n\t\treturn line.map(encodeSegment).join(',');\n\t}).join(';');\n\n\tfunction encodeSegment(segment) {\n\t\tif (!segment.length) {\n\t\t\treturn segment;\n\t\t}\n\n\t\tvar result = new Array(segment.length);\n\n\t\tresult[0] = segment[0] - offsets.generatedCodeColumn;\n\t\toffsets.generatedCodeColumn = segment[0];\n\n\t\tif (segment.length === 1) {\n\t\t\t// only one field!\n\t\t\treturn result;\n\t\t}\n\n\t\tresult[1] = segment[1] - offsets.sourceFileIndex;\n\t\tresult[2] = segment[2] - offsets.sourceCodeLine;\n\t\tresult[3] = segment[3] - offsets.sourceCodeColumn;\n\n\t\toffsets.sourceFileIndex = segment[1];\n\t\toffsets.sourceCodeLine = segment[2];\n\t\toffsets.sourceCodeColumn = segment[3];\n\n\t\tif (segment.length === 5) {\n\t\t\tresult[4] = segment[4] - offsets.nameIndex;\n\t\t\toffsets.nameIndex = segment[4];\n\t\t}\n\n\t\treturn encode(result);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/encodeMappings.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n","// css","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile } from 'sander';\nimport SourceMap from './SourceMap';\nimport encodeMappings from './utils/encodeMappings';\n\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAP_COMMENT = new RegExp('\\n*(?:' + ('\\\\/\\\\/[@#]\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)|') + ( // js\n'\\\\/\\\\*#?\\\\s*' + SOURCEMAPPING_URL + '=([^\\'\"]+)\\\\s\\\\*\\\\/)') + // css\n'\\\\s*$', 'g');\n\nvar Chain = (function () {\n\tfunction Chain(node, sourcesContentByPath) {\n\t\t_classCallCheck(this, Chain);\n\n\t\tthis.node = node;\n\t\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\t\tthis._stats = {};\n\t}\n\n\tChain.prototype.stat = function stat() {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1000000,\n\t\t\ttotalDecodingTime: (this._stats.decodingTime + tally(this.node.sources, 'decodingTime')) / 1000000,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1000000,\n\t\t\ttracingTime: this._stats.tracingTime / 1000000,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t};\n\n\tChain.prototype.apply = function apply() {\n\t\tvar _this = this;\n\n\t\tvar options = arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function (segment, result) {\n\t\t\tvar traced = _this.node.sources[segment[1]].trace( // source\n\t\t\tsegment[2], // source code line\n\t\t\tsegment[3], // source code column\n\t\t\t_this.node.map.names[segment[4]]);\n\n\t\t\tif (!traced) {\n\t\t\t\t_this._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf(traced.source);\n\t\t\tif (! ~sourceIndex) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push(traced.source);\n\t\t\t}\n\n\t\t\tvar newSegment = [segment[0], // generated code column\n\t\t\tsourceIndex, traced.line - 1, traced.column];\n\n\t\t\tif (traced.name) {\n\t\t\t\tvar nameIndex = allNames.indexOf(traced.name);\n\t\t\t\tif (! ~nameIndex) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push(traced.name);\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[result.length] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array(i);\n\n\t\tvar j = undefined,\n\t\t    line = undefined,\n\t\t    result = undefined;\n\n\t\twhile (i--) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor (j = 0; j < line.length; j += 1) {\n\t\t\t\tapplySegment(line[j], result);\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime(tracingStart);\n\t\tthis._stats.tracingTime = 1000000000 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = encodeMappings(resolved);\n\t\tvar encodingTime = process.hrtime(encodingStart);\n\t\tthis._stats.encodingTime = 1000000000 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename(this.node.file),\n\t\t\tsources: allSources.map(function (source) {\n\t\t\t\treturn relative(options.base || dirname(_this.node.file), source);\n\t\t\t}),\n\t\t\tsourcesContent: allSources.map(function (source) {\n\t\t\t\treturn includeContent ? _this.sourcesContentByPath[source] : null;\n\t\t\t}),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t};\n\n\tChain.prototype.trace = function trace(oneBasedLineIndex, zeroBasedColumnIndex) {\n\t\treturn this.node.trace(oneBasedLineIndex - 1, zeroBasedColumnIndex, null);\n\t};\n\n\tChain.prototype.write = function write(dest, options) {\n\t\tif (typeof dest !== 'string') {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\t\tdest = resolve(dest);\n\n\t\tvar map = this.apply({\n\t\t\tincludeContent: options.includeContent,\n\t\t\tbase: options.base ? resolve(options.base) : dirname(dest)\n\t\t});\n\n\t\tvar url = options.inline ? map.toUrl() : (options.absolutePath ? dest : basename(dest)) + '.map';\n\n\t\tvar content = this.node.content.replace(SOURCEMAP_COMMENT, '') + sourcemapComment(url, dest);\n\n\t\tvar promises = [writeFile(dest, content)];\n\n\t\tif (!options.inline) {\n\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t};\n\n\treturn Chain;\n})();\n\nexport default Chain;\n\nfunction tally(nodes, stat) {\n\treturn nodes.reduce(function (total, node) {\n\t\treturn total + node._stats[stat];\n\t}, 0);\n}\n\nfunction sourcemapComment(url, dest) {\n\tvar ext = extname(dest);\n\turl = encodeURI(url);\n\n\tif (ext === '.css') {\n\t\treturn '\\n/*# ' + SOURCEMAPPING_URL + '=' + url + ' */\\n';\n\t}\n\n\treturn '\\n//# ' + SOURCEMAPPING_URL + '=' + url + '\\n';\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Chain.js.map\n"," // source","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport decodeMappings from './utils/decodeMappings';\nimport getMap from './utils/getMap';\n\nvar Node = (function () {\n\tfunction Node(_ref) {\n\t\tvar file = _ref.file;\n\t\tvar content = _ref.content;\n\n\t\t_classCallCheck(this, Node);\n\n\t\tthis.file = file ? resolve(file) : null;\n\t\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\t\tif (!this.file && this.content === null) {\n\t\t\tthrow new Error('A source must specify either file or content');\n\t\t}\n\n\t\t// these get filled in later\n\t\tthis.map = null;\n\t\tthis.mappings = null;\n\t\tthis.sources = null;\n\t\tthis.isOriginalSource = null;\n\n\t\tthis._stats = {\n\t\t\tdecodingTime: 0,\n\t\t\tencodingTime: 0,\n\t\t\ttracingTime: 0,\n\n\t\t\tuntraceable: 0\n\t\t};\n\t}\n\n\tNode.prototype.load = function load(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this = this;\n\n\t\treturn getContent(this, sourcesContentByPath).then(function (content) {\n\t\t\t_this.content = sourcesContentByPath[_this.file] = content;\n\n\t\t\treturn getMap(_this, sourceMapByPath).then(function (map) {\n\t\t\t\tif (!map) return null;\n\n\t\t\t\t_this.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\t_this.mappings = decodeMappings(map.mappings);\n\t\t\t\tvar decodingTime = process.hrtime(decodingStart);\n\t\t\t\t_this._stats.decodingTime = 1000000000 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\t_this.sources = map.sources.map(function (source, i) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolveSourcePath(_this, map.sourceRoot, source) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = _this.sources.map(function (node) {\n\t\t\t\t\treturn node.load(sourcesContentByPath, sourceMapByPath);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t\t});\n\t};\n\n\tNode.prototype.loadSync = function loadSync(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this2 = this;\n\n\t\tif (!this.content) {\n\t\t\tthis.content = sourcesContentByPath[this.file] = readFileSync(this.file).toString();\n\t\t}\n\n\t\tvar map = getMap(this, sourceMapByPath, true);\n\t\tvar sourcesContent = undefined;\n\n\t\tif (!map) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = decodeMappings(map.mappings);\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tthis.sources = map.sources.map(function (source, i) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolveSourcePath(_this2, map.sourceRoot, source),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Traces a segment back to its origin\n  * @param {number} lineIndex - the zero-based line index of the\n    segment as found in `this`\n  * @param {number} columnIndex - the zero-based column index of the\n    segment as found in `this`\n  * @param {string || null} - if specified, the name that should be\n    (eventually) returned, as it is closest to the generated code\n  * @returns {object}\n      @property {string} source - the filepath of the source\n      @property {number} line - the one-based line index\n      @property {number} column - the zero-based column index\n      @property {string || null} name - the name corresponding\n      to the segment being traced\n  */\n\n\tNode.prototype.trace = function trace(lineIndex, columnIndex, name) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif (this.isOriginalSource) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[lineIndex];\n\n\t\tif (!segments || segments.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (columnIndex != null) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i = undefined;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif (generatedCodeColumn > columnIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (generatedCodeColumn === columnIndex) {\n\t\t\t\t\tvar _sourceFileIndex = segments[i][1];\n\t\t\t\t\tvar _sourceCodeLine = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar _nameIndex = segments[i][4];\n\n\t\t\t\t\tvar _parent = this.sources[_sourceFileIndex];\n\t\t\t\t\treturn _parent.trace(_sourceCodeLine, sourceCodeColumn, this.map.names[_nameIndex] || name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[sourceFileIndex];\n\t\treturn parent.trace(sourceCodeLine, null, this.map.names[nameIndex] || name);\n\t};\n\n\treturn Node;\n})();\n\nexport default Node;\n\nfunction getContent(node, sourcesContentByPath) {\n\tif (node.file in sourcesContentByPath) {\n\t\tnode.content = sourcesContentByPath[node.file];\n\t}\n\n\tif (!node.content) {\n\t\treturn readFile(node.file).then(String);\n\t}\n\n\treturn Promise.resolve(node.content);\n}\n\nfunction resolveSourcePath(node, sourceRoot, source) {\n\treturn resolve(dirname(node.file), sourceRoot || '', source);\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Node.js.map\n","\n\nexport default decodeMappings;\nimport crc32 from 'buffer-crc32';\nimport { decode } from 'vlq';\n\nvar cache = {};\n\nfunction decodeSegments(encodedSegments) {\n\tvar i = encodedSegments.length;\n\tvar segments = new Array(i);\n\n\twhile (i--) {\n\t\tsegments[i] = decode(encodedSegments[i]);\n\t}\n\n\treturn segments;\n}\nfunction decodeMappings(mappings) {\n\tvar checksum = crc32(mappings);\n\n\tif (!cache[checksum]) {\n\t\tvar sourceFileIndex = 0; // second field\n\t\tvar sourceCodeLine = 0; // third field\n\t\tvar sourceCodeColumn = 0; // fourth field\n\t\tvar nameIndex = 0; // fifth field\n\n\t\tvar lines = mappings.split(';');\n\t\tvar numLines = lines.length;\n\t\tvar decoded = new Array(numLines);\n\n\t\tvar i = undefined,\n\t\t    j = undefined,\n\t\t    line = undefined,\n\t\t    generatedCodeColumn = undefined,\n\t\t    decodedLine = undefined,\n\t\t    segments = undefined,\n\t\t    segment = undefined,\n\t\t    result = undefined;\n\n\t\tfor (i = 0; i < numLines; i += 1) {\n\t\t\tline = lines[i];\n\n\t\t\tgeneratedCodeColumn = 0; // first field - reset each time\n\t\t\tdecodedLine = [];\n\n\t\t\tsegments = decodeSegments(line.split(','));\n\n\t\t\tfor (j = 0; j < segments.length; j += 1) {\n\t\t\t\tsegment = segments[j];\n\n\t\t\t\tif (!segment.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgeneratedCodeColumn += segment[0];\n\n\t\t\t\tresult = [generatedCodeColumn];\n\t\t\t\tdecodedLine.push(result);\n\n\t\t\t\tif (segment.length === 1) {\n\t\t\t\t\t// only one field!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsourceFileIndex += segment[1];\n\t\t\t\tsourceCodeLine += segment[2];\n\t\t\t\tsourceCodeColumn += segment[3];\n\n\t\t\t\tresult.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);\n\n\t\t\t\tif (segment.length === 5) {\n\t\t\t\t\tnameIndex += segment[4];\n\t\t\t\t\tresult.push(nameIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded[i] = decodedLine;\n\t\t}\n\n\t\tcache[checksum] = decoded;\n\t}\n\n\treturn cache[checksum];\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/decodeMappings.js.map\n","\n\nexport default decodeMappings;\nimport crc32 from 'buffer-crc32';\nimport { decode } from 'vlq';\n\nvar cache = {};\n\nfunction decodeSegments(encodedSegments) {\n\tvar i = encodedSegments.length;\n\tvar segments = new Array(i);\n\n\twhile (i--) {\n\t\tsegments[i] = decode(encodedSegments[i]);\n\t}\n\n\treturn segments;\n}\nfunction decodeMappings(mappings) {\n\tvar checksum = crc32(mappings);\n\n\tif (!cache[checksum]) {\n\t\tvar sourceFileIndex = 0; // second field\n\t\tvar sourceCodeLine = 0; // third field\n\t\tvar sourceCodeColumn = 0; // fourth field\n\t\tvar nameIndex = 0; // fifth field\n\n\t\tvar lines = mappings.split(';');\n\t\tvar numLines = lines.length;\n\t\tvar decoded = new Array(numLines);\n\n\t\tvar i = undefined,\n\t\t    j = undefined,\n\t\t    line = undefined,\n\t\t    generatedCodeColumn = undefined,\n\t\t    decodedLine = undefined,\n\t\t    segments = undefined,\n\t\t    segment = undefined,\n\t\t    result = undefined;\n\n\t\tfor (i = 0; i < numLines; i += 1) {\n\t\t\tline = lines[i];\n\n\t\t\tgeneratedCodeColumn = 0; // first field - reset each time\n\t\t\tdecodedLine = [];\n\n\t\t\tsegments = decodeSegments(line.split(','));\n\n\t\t\tfor (j = 0; j < segments.length; j += 1) {\n\t\t\t\tsegment = segments[j];\n\n\t\t\t\tif (!segment.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgeneratedCodeColumn += segment[0];\n\n\t\t\t\tresult = [generatedCodeColumn];\n\t\t\t\tdecodedLine.push(result);\n\n\t\t\t\tif (segment.length === 1) {\n\t\t\t\t\t// only one field!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsourceFileIndex += segment[1];\n\t\t\t\tsourceCodeLine += segment[2];\n\t\t\t\tsourceCodeColumn += segment[3];\n\n\t\t\t\tresult.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);\n\n\t\t\t\tif (segment.length === 5) {\n\t\t\t\t\tnameIndex += segment[4];\n\t\t\t\t\tresult.push(nameIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded[i] = decodedLine;\n\t\t}\n\n\t\tcache[checksum] = decoded;\n\t}\n\n\treturn cache[checksum];\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/decodeMappings.js.map\n","\n\nexport default decodeMappings;\nimport crc32 from 'buffer-crc32';\nimport { decode } from 'vlq';\n\nvar cache = {};\n\nfunction decodeSegments(encodedSegments) {\n\tvar i = encodedSegments.length;\n\tvar segments = new Array(i);\n\n\twhile (i--) {\n\t\tsegments[i] = decode(encodedSegments[i]);\n\t}\n\n\treturn segments;\n}\nfunction decodeMappings(mappings) {\n\tvar checksum = crc32(mappings);\n\n\tif (!cache[checksum]) {\n\t\tvar sourceFileIndex = 0; // second field\n\t\tvar sourceCodeLine = 0; // third field\n\t\tvar sourceCodeColumn = 0; // fourth field\n\t\tvar nameIndex = 0; // fifth field\n\n\t\tvar lines = mappings.split(';');\n\t\tvar numLines = lines.length;\n\t\tvar decoded = new Array(numLines);\n\n\t\tvar i = undefined,\n\t\t    j = undefined,\n\t\t    line = undefined,\n\t\t    generatedCodeColumn = undefined,\n\t\t    decodedLine = undefined,\n\t\t    segments = undefined,\n\t\t    segment = undefined,\n\t\t    result = undefined;\n\n\t\tfor (i = 0; i < numLines; i += 1) {\n\t\t\tline = lines[i];\n\n\t\t\tgeneratedCodeColumn = 0; // first field - reset each time\n\t\t\tdecodedLine = [];\n\n\t\t\tsegments = decodeSegments(line.split(','));\n\n\t\t\tfor (j = 0; j < segments.length; j += 1) {\n\t\t\t\tsegment = segments[j];\n\n\t\t\t\tif (!segment.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgeneratedCodeColumn += segment[0];\n\n\t\t\t\tresult = [generatedCodeColumn];\n\t\t\t\tdecodedLine.push(result);\n\n\t\t\t\tif (segment.length === 1) {\n\t\t\t\t\t// only one field!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsourceFileIndex += segment[1];\n\t\t\t\tsourceCodeLine += segment[2];\n\t\t\t\tsourceCodeColumn += segment[3];\n\n\t\t\t\tresult.push(sourceFileIndex, sourceCodeLine, sourceCodeColumn);\n\n\t\t\t\tif (segment.length === 5) {\n\t\t\t\t\tnameIndex += segment[4];\n\t\t\t\t\tresult.push(nameIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded[i] = decodedLine;\n\t\t}\n\n\t\tcache[checksum] = decoded;\n\t}\n\n\treturn cache[checksum];\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/decodeMappings.js.map\n","/**\n * Decodes a base64 string\n * @param {string} base64 - the string to decode\n * @returns {string}\n */\nexport default atob;\n\nfunction atob(base64) {\n  return new Buffer(base64, 'base64').toString('utf8');\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/atob.js.map\n","\n\n/**\n * Turns a sourceMappingURL into a sourcemap\n * @param {string} url - the URL (i.e. sourceMappingURL=url). Can\n   be a base64-encoded data URI\n * @param {string} base - the URL against which relative URLS\n   should be resolved\n * @param {boolean} sync - if `true`, return a promise, otherwise\n   return the sourcemap\n * @returns {object} - a version 3 sourcemap\n */\nexport default getMapFromUrl;\nimport { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport atob from './atob';\nfunction getMapFromUrl(url, base, sync) {\n\tif (/^data:/.test(url)) {\n\t\t// TODO beef this up\n\t\tvar match = /base64,(.+)$/.exec(url);\n\n\t\tif (!match) {\n\t\t\tthrow new Error('sourceMappingURL is not base64-encoded');\n\t\t}\n\n\t\tvar json = atob(match[1]);\n\t\tvar map = JSON.parse(json);\n\t\treturn sync ? map : Promise.resolve(map);\n\t}\n\n\turl = resolve(dirname(base), decodeURI(url));\n\n\tif (sync) {\n\t\treturn JSON.parse(readFileSync(url).toString());\n\t} else {\n\t\treturn readFile(url).then(String).then(JSON.parse);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getMapFromUrl.js.map\n","export default getSourceMappingUrl;\n\nfunction getSourceMappingUrl(str) {\n\tvar index, substring, url, match;\n\n\t// assume we want the last occurence\n\tindex = str.lastIndexOf('sourceMappingURL=');\n\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\tsubstring = str.substring(index + 17);\n\tmatch = /^[^\\r\\n]+/.exec(substring);\n\n\turl = match ? match[0] : null;\n\n\t// possibly a better way to do this, but we don't want to exclude whitespace\n\t// from the sourceMappingURL because it might not have been correctly encoded\n\tif (url && url.slice(-2) === '*/') {\n\t\turl = url.slice(0, -2).trim();\n\t}\n\n\treturn url;\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getSourceMappingUrl.js.map\n","\n\nexport default getMap;\nimport getMapFromUrl from './getMapFromUrl';\nimport getSourceMappingUrl from './getSourceMappingUrl';\nimport { Promise } from 'sander';\nfunction getMap(node, sourceMapByPath, sync) {\n\tif (node.file in sourceMapByPath) {\n\t\tvar map = sourceMapByPath[node.file];\n\t\treturn sync ? map : Promise.resolve(map);\n\t} else {\n\t\tvar url = getSourceMappingUrl(node.content);\n\n\t\tif (!url) {\n\t\t\tnode.isOriginalSource = true;\n\t\t\treturn sync ? null : Promise.resolve(null);\n\t\t}\n\n\t\treturn getMapFromUrl(url, node.file, sync);\n\t}\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/utils/getMap.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport decodeMappings from './utils/decodeMappings';\nimport getMap from './utils/getMap';\n\nvar Node = (function () {\n\tfunction Node(_ref) {\n\t\tvar file = _ref.file;\n\t\tvar content = _ref.content;\n\n\t\t_classCallCheck(this, Node);\n\n\t\tthis.file = file ? resolve(file) : null;\n\t\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\t\tif (!this.file && this.content === null) {\n\t\t\tthrow new Error('A source must specify either file or content');\n\t\t}\n\n\t\t// these get filled in later\n\t\tthis.map = null;\n\t\tthis.mappings = null;\n\t\tthis.sources = null;\n\t\tthis.isOriginalSource = null;\n\n\t\tthis._stats = {\n\t\t\tdecodingTime: 0,\n\t\t\tencodingTime: 0,\n\t\t\ttracingTime: 0,\n\n\t\t\tuntraceable: 0\n\t\t};\n\t}\n\n\tNode.prototype.load = function load(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this = this;\n\n\t\treturn getContent(this, sourcesContentByPath).then(function (content) {\n\t\t\t_this.content = sourcesContentByPath[_this.file] = content;\n\n\t\t\treturn getMap(_this, sourceMapByPath).then(function (map) {\n\t\t\t\tif (!map) return null;\n\n\t\t\t\t_this.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\t_this.mappings = decodeMappings(map.mappings);\n\t\t\t\tvar decodingTime = process.hrtime(decodingStart);\n\t\t\t\t_this._stats.decodingTime = 1000000000 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\t_this.sources = map.sources.map(function (source, i) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolveSourcePath(_this, map.sourceRoot, source) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = _this.sources.map(function (node) {\n\t\t\t\t\treturn node.load(sourcesContentByPath, sourceMapByPath);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t\t});\n\t};\n\n\tNode.prototype.loadSync = function loadSync(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this2 = this;\n\n\t\tif (!this.content) {\n\t\t\tthis.content = sourcesContentByPath[this.file] = readFileSync(this.file).toString();\n\t\t}\n\n\t\tvar map = getMap(this, sourceMapByPath, true);\n\t\tvar sourcesContent = undefined;\n\n\t\tif (!map) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = decodeMappings(map.mappings);\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tthis.sources = map.sources.map(function (source, i) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolveSourcePath(_this2, map.sourceRoot, source),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Traces a segment back to its origin\n  * @param {number} lineIndex - the zero-based line index of the\n    segment as found in `this`\n  * @param {number} columnIndex - the zero-based column index of the\n    segment as found in `this`\n  * @param {string || null} - if specified, the name that should be\n    (eventually) returned, as it is closest to the generated code\n  * @returns {object}\n      @property {string} source - the filepath of the source\n      @property {number} line - the one-based line index\n      @property {number} column - the zero-based column index\n      @property {string || null} name - the name corresponding\n      to the segment being traced\n  */\n\n\tNode.prototype.trace = function trace(lineIndex, columnIndex, name) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif (this.isOriginalSource) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[lineIndex];\n\n\t\tif (!segments || segments.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (columnIndex != null) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i = undefined;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif (generatedCodeColumn > columnIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (generatedCodeColumn === columnIndex) {\n\t\t\t\t\tvar _sourceFileIndex = segments[i][1];\n\t\t\t\t\tvar _sourceCodeLine = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar _nameIndex = segments[i][4];\n\n\t\t\t\t\tvar _parent = this.sources[_sourceFileIndex];\n\t\t\t\t\treturn _parent.trace(_sourceCodeLine, sourceCodeColumn, this.map.names[_nameIndex] || name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[sourceFileIndex];\n\t\treturn parent.trace(sourceCodeLine, null, this.map.names[nameIndex] || name);\n\t};\n\n\treturn Node;\n})();\n\nexport default Node;\n\nfunction getContent(node, sourcesContentByPath) {\n\tif (node.file in sourcesContentByPath) {\n\t\tnode.content = sourcesContentByPath[node.file];\n\t}\n\n\tif (!node.content) {\n\t\treturn readFile(node.file).then(String);\n\t}\n\n\treturn Promise.resolve(node.content);\n}\n\nfunction resolveSourcePath(node, sourceRoot, source) {\n\treturn resolve(dirname(node.file), sourceRoot || '', source);\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Node.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport decodeMappings from './utils/decodeMappings';\nimport getMap from './utils/getMap';\n\nvar Node = (function () {\n\tfunction Node(_ref) {\n\t\tvar file = _ref.file;\n\t\tvar content = _ref.content;\n\n\t\t_classCallCheck(this, Node);\n\n\t\tthis.file = file ? resolve(file) : null;\n\t\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\t\tif (!this.file && this.content === null) {\n\t\t\tthrow new Error('A source must specify either file or content');\n\t\t}\n\n\t\t// these get filled in later\n\t\tthis.map = null;\n\t\tthis.mappings = null;\n\t\tthis.sources = null;\n\t\tthis.isOriginalSource = null;\n\n\t\tthis._stats = {\n\t\t\tdecodingTime: 0,\n\t\t\tencodingTime: 0,\n\t\t\ttracingTime: 0,\n\n\t\t\tuntraceable: 0\n\t\t};\n\t}\n\n\tNode.prototype.load = function load(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this = this;\n\n\t\treturn getContent(this, sourcesContentByPath).then(function (content) {\n\t\t\t_this.content = sourcesContentByPath[_this.file] = content;\n\n\t\t\treturn getMap(_this, sourceMapByPath).then(function (map) {\n\t\t\t\tif (!map) return null;\n\n\t\t\t\t_this.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\t_this.mappings = decodeMappings(map.mappings);\n\t\t\t\tvar decodingTime = process.hrtime(decodingStart);\n\t\t\t\t_this._stats.decodingTime = 1000000000 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\t_this.sources = map.sources.map(function (source, i) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolveSourcePath(_this, map.sourceRoot, source) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = _this.sources.map(function (node) {\n\t\t\t\t\treturn node.load(sourcesContentByPath, sourceMapByPath);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t\t});\n\t};\n\n\tNode.prototype.loadSync = function loadSync(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this2 = this;\n\n\t\tif (!this.content) {\n\t\t\tthis.content = sourcesContentByPath[this.file] = readFileSync(this.file).toString();\n\t\t}\n\n\t\tvar map = getMap(this, sourceMapByPath, true);\n\t\tvar sourcesContent = undefined;\n\n\t\tif (!map) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = decodeMappings(map.mappings);\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tthis.sources = map.sources.map(function (source, i) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolveSourcePath(_this2, map.sourceRoot, source),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Traces a segment back to its origin\n  * @param {number} lineIndex - the zero-based line index of the\n    segment as found in `this`\n  * @param {number} columnIndex - the zero-based column index of the\n    segment as found in `this`\n  * @param {string || null} - if specified, the name that should be\n    (eventually) returned, as it is closest to the generated code\n  * @returns {object}\n      @property {string} source - the filepath of the source\n      @property {number} line - the one-based line index\n      @property {number} column - the zero-based column index\n      @property {string || null} name - the name corresponding\n      to the segment being traced\n  */\n\n\tNode.prototype.trace = function trace(lineIndex, columnIndex, name) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif (this.isOriginalSource) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[lineIndex];\n\n\t\tif (!segments || segments.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (columnIndex != null) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i = undefined;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif (generatedCodeColumn > columnIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (generatedCodeColumn === columnIndex) {\n\t\t\t\t\tvar _sourceFileIndex = segments[i][1];\n\t\t\t\t\tvar _sourceCodeLine = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar _nameIndex = segments[i][4];\n\n\t\t\t\t\tvar _parent = this.sources[_sourceFileIndex];\n\t\t\t\t\treturn _parent.trace(_sourceCodeLine, sourceCodeColumn, this.map.names[_nameIndex] || name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[sourceFileIndex];\n\t\treturn parent.trace(sourceCodeLine, null, this.map.names[nameIndex] || name);\n\t};\n\n\treturn Node;\n})();\n\nexport default Node;\n\nfunction getContent(node, sourcesContentByPath) {\n\tif (node.file in sourcesContentByPath) {\n\t\tnode.content = sourcesContentByPath[node.file];\n\t}\n\n\tif (!node.content) {\n\t\treturn readFile(node.file).then(String);\n\t}\n\n\treturn Promise.resolve(node.content);\n}\n\nfunction resolveSourcePath(node, sourceRoot, source) {\n\treturn resolve(dirname(node.file), sourceRoot || '', source);\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Node.js.map\n","var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\n\nimport { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport decodeMappings from './utils/decodeMappings';\nimport getMap from './utils/getMap';\n\nvar Node = (function () {\n\tfunction Node(_ref) {\n\t\tvar file = _ref.file;\n\t\tvar content = _ref.content;\n\n\t\t_classCallCheck(this, Node);\n\n\t\tthis.file = file ? resolve(file) : null;\n\t\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\t\tif (!this.file && this.content === null) {\n\t\t\tthrow new Error('A source must specify either file or content');\n\t\t}\n\n\t\t// these get filled in later\n\t\tthis.map = null;\n\t\tthis.mappings = null;\n\t\tthis.sources = null;\n\t\tthis.isOriginalSource = null;\n\n\t\tthis._stats = {\n\t\t\tdecodingTime: 0,\n\t\t\tencodingTime: 0,\n\t\t\ttracingTime: 0,\n\n\t\t\tuntraceable: 0\n\t\t};\n\t}\n\n\tNode.prototype.load = function load(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this = this;\n\n\t\treturn getContent(this, sourcesContentByPath).then(function (content) {\n\t\t\t_this.content = sourcesContentByPath[_this.file] = content;\n\n\t\t\treturn getMap(_this, sourceMapByPath).then(function (map) {\n\t\t\t\tif (!map) return null;\n\n\t\t\t\t_this.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\t_this.mappings = decodeMappings(map.mappings);\n\t\t\t\tvar decodingTime = process.hrtime(decodingStart);\n\t\t\t\t_this._stats.decodingTime = 1000000000 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\t_this.sources = map.sources.map(function (source, i) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolveSourcePath(_this, map.sourceRoot, source) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = _this.sources.map(function (node) {\n\t\t\t\t\treturn node.load(sourcesContentByPath, sourceMapByPath);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t\t});\n\t};\n\n\tNode.prototype.loadSync = function loadSync(sourcesContentByPath, sourceMapByPath) {\n\t\tvar _this2 = this;\n\n\t\tif (!this.content) {\n\t\t\tthis.content = sourcesContentByPath[this.file] = readFileSync(this.file).toString();\n\t\t}\n\n\t\tvar map = getMap(this, sourceMapByPath, true);\n\t\tvar sourcesContent = undefined;\n\n\t\tif (!map) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = decodeMappings(map.mappings);\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tthis.sources = map.sources.map(function (source, i) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolveSourcePath(_this2, map.sourceRoot, source),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Traces a segment back to its origin\n  * @param {number} lineIndex - the zero-based line index of the\n    segment as found in `this`\n  * @param {number} columnIndex - the zero-based column index of the\n    segment as found in `this`\n  * @param {string || null} - if specified, the name that should be\n    (eventually) returned, as it is closest to the generated code\n  * @returns {object}\n      @property {string} source - the filepath of the source\n      @property {number} line - the one-based line index\n      @property {number} column - the zero-based column index\n      @property {string || null} name - the name corresponding\n      to the segment being traced\n  */\n\n\tNode.prototype.trace = function trace(lineIndex, columnIndex, name) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif (this.isOriginalSource) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[lineIndex];\n\n\t\tif (!segments || segments.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (columnIndex != null) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i = undefined;\n\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif (generatedCodeColumn > columnIndex) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (generatedCodeColumn === columnIndex) {\n\t\t\t\t\tvar _sourceFileIndex = segments[i][1];\n\t\t\t\t\tvar _sourceCodeLine = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar _nameIndex = segments[i][4];\n\n\t\t\t\t\tvar _parent = this.sources[_sourceFileIndex];\n\t\t\t\t\treturn _parent.trace(_sourceCodeLine, sourceCodeColumn, this.map.names[_nameIndex] || name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[sourceFileIndex];\n\t\treturn parent.trace(sourceCodeLine, null, this.map.names[nameIndex] || name);\n\t};\n\n\treturn Node;\n})();\n\nexport default Node;\n\nfunction getContent(node, sourcesContentByPath) {\n\tif (node.file in sourcesContentByPath) {\n\t\tnode.content = sourcesContentByPath[node.file];\n\t}\n\n\tif (!node.content) {\n\t\treturn readFile(node.file).then(String);\n\t}\n\n\treturn Promise.resolve(node.content);\n}\n\nfunction resolveSourcePath(node, sourceRoot, source) {\n\treturn resolve(dirname(node.file), sourceRoot || '', source);\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/Node.js.map\n"," // sometimes exists in sourcesContent, sometimes doesn't","\n\nexport { load };\n\nexport { loadSync };\n\nimport { resolve } from 'path';\nimport Node from './Node';\nimport Chain from './Chain';\nfunction load(file, options) {\n\tvar _init = init(file, options);\n\n\tvar node = _init.node;\n\tvar sourcesContentByPath = _init.sourcesContentByPath;\n\tvar sourceMapByPath = _init.sourceMapByPath;\n\n\treturn node.load(sourcesContentByPath, sourceMapByPath).then(function () {\n\t\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n\t});\n}\n\nfunction loadSync(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar _init2 = init(file, options);\n\n\tvar node = _init2.node;\n\tvar sourcesContentByPath = _init2.sourcesContentByPath;\n\tvar sourceMapByPath = _init2.sourceMapByPath;\n\n\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n}\n\nfunction init(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif (options.content) {\n\t\tObject.keys(options.content).forEach(function (key) {\n\t\t\tsourcesContentByPath[resolve(key)] = options.content[key];\n\t\t});\n\t}\n\n\tif (options.sourcemaps) {\n\t\tObject.keys(options.sourcemaps).forEach(function (key) {\n\t\t\tsourceMapByPath[resolve(key)] = options.sourcemaps[key];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/index.js.map\n","\n\nexport { load };\n\nexport { loadSync };\n\nimport { resolve } from 'path';\nimport Node from './Node';\nimport Chain from './Chain';\nfunction load(file, options) {\n\tvar _init = init(file, options);\n\n\tvar node = _init.node;\n\tvar sourcesContentByPath = _init.sourcesContentByPath;\n\tvar sourceMapByPath = _init.sourceMapByPath;\n\n\treturn node.load(sourcesContentByPath, sourceMapByPath).then(function () {\n\t\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n\t});\n}\n\nfunction loadSync(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar _init2 = init(file, options);\n\n\tvar node = _init2.node;\n\tvar sourcesContentByPath = _init2.sourcesContentByPath;\n\tvar sourceMapByPath = _init2.sourceMapByPath;\n\n\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n}\n\nfunction init(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif (options.content) {\n\t\tObject.keys(options.content).forEach(function (key) {\n\t\t\tsourcesContentByPath[resolve(key)] = options.content[key];\n\t\t});\n\t}\n\n\tif (options.sourcemaps) {\n\t\tObject.keys(options.sourcemaps).forEach(function (key) {\n\t\t\tsourceMapByPath[resolve(key)] = options.sourcemaps[key];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/index.js.map\n","\n\nexport { load };\n\nexport { loadSync };\n\nimport { resolve } from 'path';\nimport Node from './Node';\nimport Chain from './Chain';\nfunction load(file, options) {\n\tvar _init = init(file, options);\n\n\tvar node = _init.node;\n\tvar sourcesContentByPath = _init.sourcesContentByPath;\n\tvar sourceMapByPath = _init.sourceMapByPath;\n\n\treturn node.load(sourcesContentByPath, sourceMapByPath).then(function () {\n\t\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n\t});\n}\n\nfunction loadSync(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar _init2 = init(file, options);\n\n\tvar node = _init2.node;\n\tvar sourcesContentByPath = _init2.sourcesContentByPath;\n\tvar sourceMapByPath = _init2.sourceMapByPath;\n\n\tnode.loadSync(sourcesContentByPath, sourceMapByPath);\n\treturn node.isOriginalSource ? null : new Chain(node, sourcesContentByPath);\n}\n\nfunction init(file) {\n\tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif (options.content) {\n\t\tObject.keys(options.content).forEach(function (key) {\n\t\t\tsourcesContentByPath[resolve(key)] = options.content[key];\n\t\t});\n\t}\n\n\tif (options.sourcemaps) {\n\t\tObject.keys(options.sourcemaps).forEach(function (key) {\n\t\t\tsourceMapByPath[resolve(key)] = options.sourcemaps[key];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n//# sourceMappingURL=/www/sorcery/.gobble-build/01-babel/.cache/index.js.map\n","\n\nexports.load = load;\nexports.loadSync = loadSync;"],"names":[],"mappings":";;;;;;;;AAOAACCAAC0JA;AACA,WAnKA,YAmKkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACAACjKA;AACA;AACAACZAACOA;AACA;AACAACTA,IAAA,gBAAmBACInB;AACA;AACA,EANA,gBAMiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACAACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SA9CA,UA8Ce;AACf;AACAAC4GA;AACA;AACA;AACA;AACAAChKA,IAAA,iBAAmBACAnBACcA;AACA;AACA,EAhBA,iBAgBiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SA5GA,aA4GiB;AACjB;AACA,WA9GA,aA8GmB,iBA9GnB,YA8G2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAnIA,YAmIgB;;AAEhB;AACA;AACA,wBAvIA,YAuI+B,iBAvI/B,YAuIuD;AACvD;;AAEA,0EA1IA,aA0IkF;;AAElF;;AAEA,kBA9IA,gBA8I2B;;AAE3B;AACA,iBAjJA,gBAiJ0B;AAC1B;;AAEA;AACA;;AAEA;AACAACxJAACwLA;AACA,QAzLA,YAyLe,CAzLf,YAyLuB;AACvBACpLAACEA;AACA;AACA;;AAEA;AACA,gBAbA,UAasB;AACtB;;AAEA;AACAACCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACAAC7EA;AACA;AACAACOA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBA3BA,cA2B6B;AAC7B;;AAEA,OA9BA,YA8Bc,CA9Bd,YA8BsB;;AAEtB;AACA,oBAjCA,mBAiCgC;AAChC;AACA,SAnCA,eAmCiB;AACjB;AACAACnCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACAAClBA;AACA;AACA;AACA,sBATA,cAS6B;AAC7B;AACA;;AAEA;AACA;AACA,wBAfA,cAe+B;AAC/B;;AAEA;AACA;AACAACwJA;AACA;AACA;AACA;;AAEA;AACA,SAlLA,eAkLiB;AACjB;;AAEA,QArLA,cAqLe;AACfACtLAACOA;AACA;AACA;AACA;;AAEA;;AAEA,qBAdA,YAc4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAhEA,cAgEkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAzEA,mBAyEgE;AAChE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACAACxKAACkCA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBA5CA,YA4C+B;AAC/B;AACA;;AAEA;AACA;AACA,mBAlDA,YAkD0B;AAC1B;AACA;;AAEA;AACAAC9CA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACAACEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AC9BA;AACA"}